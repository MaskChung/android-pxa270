<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SGL: SkColorPriv.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.0 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">skia</a></div>
<h1>SkColorPriv.h</h1><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#ifndef SkColorPriv_DEFINED</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define SkColorPriv_DEFINED</span>
00003 <span class="preprocessor"></span>
00004 <span class="preprocessor">#include "<a class="code" href="SkColor_8h.html">SkColor.h</a>"</span>
00005 
00006 <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> SkAlpha255To256(U8CPU alpha)
00007 {
00008         SkASSERT(SkToU8(alpha) == alpha);
00009         <span class="keywordflow">return</span> alpha + (alpha &gt;&gt; 7);
00010 }
00011 
00012 <span class="preprocessor">#define SkAlphaMul(value, alpha256)             ((value) * (alpha256) &gt;&gt; 8)</span>
00013 <span class="preprocessor"></span>
00014 <span class="comment">//      The caller may want negative values, so keep all params signed (int)</span>
00015 <span class="comment">//      so we don't accidentally slip into unsigned math and lose the sign</span>
00016 <span class="comment">//      extension when we shift (in SkAlphaMul)</span>
00017 <span class="keyword">inline</span> <span class="keywordtype">int</span> SkAlphaBlend(<span class="keywordtype">int</span> src, <span class="keywordtype">int</span> dst, <span class="keywordtype">int</span> scale256)
00018 {
00019         SkASSERT((<span class="keywordtype">unsigned</span>)scale256 &lt;= 256);
00020         <span class="keywordflow">return</span> dst + SkAlphaMul(src - dst, scale256);
00021 }
00022 
00023 <span class="preprocessor">#ifdef SK_BITMAP_16BIT_IS_555</span>
00024 <span class="preprocessor"></span><span class="preprocessor">        #define SK_R16_BITS             5</span>
00025 <span class="preprocessor"></span><span class="preprocessor">        #define SK_G16_BITS             5</span>
00026 <span class="preprocessor"></span><span class="preprocessor">        #define SK_B16_BITS             5</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00028 <span class="preprocessor"></span><span class="preprocessor">        #define SK_R16_BITS             5</span>
00029 <span class="preprocessor"></span><span class="preprocessor">        #define SK_G16_BITS             6</span>
00030 <span class="preprocessor"></span><span class="preprocessor">        #define SK_B16_BITS             5</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00032 <span class="preprocessor"></span>
00033 <span class="preprocessor">#define SK_R16_SHIFT    (SK_B16_BITS + SK_G16_BITS)</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#define SK_G16_SHIFT    (SK_B16_BITS)</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define SK_B16_SHIFT    0</span>
00036 <span class="preprocessor"></span>
00037 <span class="preprocessor">#define SK_R16_MASK             ((1 &lt;&lt; SK_R16_BITS) - 1)</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#define SK_G16_MASK             ((1 &lt;&lt; SK_G16_BITS) - 1)</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define SK_B16_MASK             ((1 &lt;&lt; SK_B16_BITS) - 1)</span>
00040 <span class="preprocessor"></span>
00041 <span class="preprocessor">#define SkGetPackedR16(color)   (((unsigned)(color) &gt;&gt; SK_R16_SHIFT) &amp; SK_R16_MASK)</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#define SkGetPackedG16(color)   (((unsigned)(color) &gt;&gt; SK_G16_SHIFT) &amp; SK_G16_MASK)</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#define SkGetPackedB16(color)   (((unsigned)(color) &gt;&gt; SK_B16_SHIFT) &amp; SK_B16_MASK)</span>
00044 <span class="preprocessor"></span>
00045 <span class="keyword">inline</span> U16 SkPackRGB16(<span class="keywordtype">unsigned</span> r, <span class="keywordtype">unsigned</span> g, <span class="keywordtype">unsigned</span> b)
00046 {
00047         SkASSERT(r &lt;= SK_R16_MASK);
00048         SkASSERT(g &lt;= SK_G16_MASK);
00049         SkASSERT(b &lt;= SK_B16_MASK);
00050 
00051         <span class="keywordflow">return</span> SkToU16((r &lt;&lt; SK_R16_SHIFT) | (g &lt;&lt; SK_G16_SHIFT) | (b &lt;&lt; SK_B16_SHIFT));
00052 }
00053 
00054 <span class="preprocessor">#define SK_R16_MASK_IN_PLACE            (SK_R16_MASK &lt;&lt; SK_R16_SHIFT)</span>
00055 <span class="preprocessor"></span><span class="preprocessor">#define SK_G16_MASK_IN_PLACE            (SK_G16_MASK &lt;&lt; SK_G16_SHIFT)</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#define SK_B16_MASK_IN_PLACE            (SK_B16_MASK &lt;&lt; SK_B16_SHIFT)</span>
00057 <span class="preprocessor"></span>
00058 <span class="preprocessor">#define SK_R16B16_MASK_IN_PLACE         (SK_R16_MASK_IN_PLACE | SK_B16_MASK_IN_PLACE)</span>
00059 <span class="preprocessor"></span>
00060 <span class="keyword">inline</span> U16CPU SkAlphaMulRGB16(U16CPU c, <span class="keywordtype">unsigned</span> scale)
00061 {
00062 <span class="preprocessor">#if SK_G16_MASK_IN_PLACE != 0x07E0</span>
00063 <span class="preprocessor"></span>        <span class="keywordflow">return</span> SkPackRGB16(     SkAlphaMul(SkGetPackedR16(c), scale),
00064                                                 SkAlphaMul(SkGetPackedG16(c), scale),
00065                                                 SkAlphaMul(SkGetPackedB16(c), scale));
00066 <span class="preprocessor">#else</span>
00067 <span class="preprocessor"></span>        scale &gt;&gt;= (8 - SK_G16_BITS);
00068         uint32_t rb = (c &amp; SK_R16B16_MASK_IN_PLACE) * scale &gt;&gt; SK_G16_BITS;
00069         uint32_t  g = (c &amp; SK_G16_MASK_IN_PLACE) * scale &gt;&gt; SK_G16_BITS;
00070         <span class="keywordflow">return</span> (g &amp; SK_G16_MASK_IN_PLACE) | (rb &amp; SK_R16B16_MASK_IN_PLACE);
00071 <span class="preprocessor">#endif</span>
00072 <span class="preprocessor"></span>}
00073 
00074 <span class="keyword">inline</span> U16CPU SkBlendRGB16(U16CPU src, U16CPU dst, <span class="keywordtype">unsigned</span> scale)
00075 {
00076         SkASSERT(scale &lt;= 256);
00077 
00078         <span class="keywordflow">return</span> SkPackRGB16(     SkAlphaBlend(SkGetPackedR16(src), SkGetPackedR16(dst), scale),
00079                                                 SkAlphaBlend(SkGetPackedG16(src), SkGetPackedG16(dst), scale),
00080                                                 SkAlphaBlend(SkGetPackedB16(src), SkGetPackedB16(dst), scale));
00081 }
00082 
00084 
00085 <span class="preprocessor">#define SK_A32_BITS             8</span>
00086 <span class="preprocessor"></span><span class="preprocessor">#define SK_R32_BITS             8</span>
00087 <span class="preprocessor"></span><span class="preprocessor">#define SK_G32_BITS             8</span>
00088 <span class="preprocessor"></span><span class="preprocessor">#define SK_B32_BITS             8</span>
00089 <span class="preprocessor"></span>
00090 <span class="preprocessor">#define SK_A32_SHIFT    24</span>
00091 <span class="preprocessor"></span><span class="preprocessor">#define SK_R32_SHIFT    16</span>
00092 <span class="preprocessor"></span><span class="preprocessor">#define SK_G32_SHIFT    8</span>
00093 <span class="preprocessor"></span><span class="preprocessor">#define SK_B32_SHIFT    0</span>
00094 <span class="preprocessor"></span>
00095 <span class="preprocessor">#define SK_A32_MASK             ((1 &lt;&lt; SK_A32_BITS) - 1)</span>
00096 <span class="preprocessor"></span><span class="preprocessor">#define SK_R32_MASK             ((1 &lt;&lt; SK_R32_BITS) - 1)</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#define SK_G32_MASK             ((1 &lt;&lt; SK_G32_BITS) - 1)</span>
00098 <span class="preprocessor"></span><span class="preprocessor">#define SK_B32_MASK             ((1 &lt;&lt; SK_B32_BITS) - 1)</span>
00099 <span class="preprocessor"></span>
00100 <span class="preprocessor">#define SkGetPackedA32(packed)          ((uint32_t)((packed) &lt;&lt; (24 - SK_A32_SHIFT)) &gt;&gt; 24)</span>
00101 <span class="preprocessor"></span><span class="preprocessor">#define SkGetPackedR32(packed)          ((uint32_t)((packed) &lt;&lt; (24 - SK_R32_SHIFT)) &gt;&gt; 24)</span>
00102 <span class="preprocessor"></span><span class="preprocessor">#define SkGetPackedG32(packed)          ((uint32_t)((packed) &lt;&lt; (24 - SK_G32_SHIFT)) &gt;&gt; 24)</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#define SkGetPackedB32(packed)          ((uint32_t)((packed) &lt;&lt; (24 - SK_B32_SHIFT)) &gt;&gt; 24)</span>
00104 <span class="preprocessor"></span>
00105 <span class="keyword">inline</span> <a class="code" href="SkColor_8h.html#a18">SkPMColor</a> SkPackARGB32(U8CPU a, U8CPU r, U8CPU g, U8CPU b)
00106 {
00107         SkASSERT(a &lt;= SK_A32_MASK);
00108         SkASSERT(r &lt;= a);
00109         SkASSERT(g &lt;= a);
00110         SkASSERT(b &lt;= a);
00111 
00112         <span class="keywordflow">return</span> (a &lt;&lt; SK_A32_SHIFT) | (r &lt;&lt; SK_R32_SHIFT) | (g &lt;&lt; SK_G32_SHIFT) | (b &lt;&lt; SK_B32_SHIFT);
00113 }
00114 
00115 <span class="keyword">inline</span> uint32_t SkAlphaMulQ(uint32_t c, <span class="keywordtype">unsigned</span> scale)
00116 {
00117         uint32_t rb = ((c &amp; 0xFF00FF) * scale) &gt;&gt; 8;
00118         uint32_t ag = ((c &gt;&gt; 8) &amp; 0xFF00FF) * scale;
00119         <span class="keywordflow">return</span> (rb &amp; 0xFF00FF) | (ag &amp; ~0xFF00FF);
00120 }
00121 
00122 <span class="keyword">inline</span> <a class="code" href="SkColor_8h.html#a18">SkPMColor</a> SkPMSrcOver(SkPMColor src, SkPMColor dst)
00123 {
00124         <span class="keywordflow">return</span> src + SkAlphaMulQ(dst, SkAlpha255To256(255 - SkGetPackedA32(src)));
00125 }
00126 
00127 <span class="keyword">inline</span> <a class="code" href="SkColor_8h.html#a18">SkPMColor</a> SkBlendARGB32(SkPMColor src, SkPMColor dst, U8CPU aa)
00128 {
00129         SkASSERT((<span class="keywordtype">unsigned</span>)aa &lt;= 255);
00130 
00131         <span class="keywordtype">unsigned</span> src_scale = SkAlpha255To256(aa);
00132         <span class="keywordtype">unsigned</span> dst_scale = SkAlpha255To256(255 - SkAlphaMul(SkGetPackedA32(src), src_scale));
00133 
00134         <span class="keywordflow">return</span> SkAlphaMulQ(src, src_scale) + SkAlphaMulQ(dst, dst_scale);
00135 }
00136 
00138 <span class="comment">// Convert a 32bit pixel to a 16bit pixel (no dither)</span>
00139 
00140 <span class="preprocessor">#define SkR32ToR16(r)   ((unsigned)(r) &gt;&gt; (SK_R32_BITS - SK_R16_BITS))</span>
00141 <span class="preprocessor"></span><span class="preprocessor">#define SkG32ToG16(g)   ((unsigned)(g) &gt;&gt; (SK_G32_BITS - SK_G16_BITS))</span>
00142 <span class="preprocessor"></span><span class="preprocessor">#define SkB32ToB16(b)   ((unsigned)(b) &gt;&gt; (SK_B32_BITS - SK_B16_BITS))</span>
00143 <span class="preprocessor"></span>
00144 <span class="preprocessor">#define SkPacked32ToR16(c)      (((unsigned)(c) &gt;&gt; (SK_R32_SHIFT + SK_R32_BITS - SK_R16_BITS)) &amp; SK_R16_MASK)</span>
00145 <span class="preprocessor"></span><span class="preprocessor">#define SkPacked32ToG16(c)      (((unsigned)(c) &gt;&gt; (SK_G32_SHIFT + SK_G32_BITS - SK_G16_BITS)) &amp; SK_G16_MASK)</span>
00146 <span class="preprocessor"></span><span class="preprocessor">#define SkPacked32ToB16(c)      (((unsigned)(c) &gt;&gt; (SK_B32_SHIFT + SK_B32_BITS - SK_B16_BITS)) &amp; SK_B16_MASK)</span>
00147 <span class="preprocessor"></span>
00148 <span class="keyword">inline</span> U16CPU SkPixel32ToPixel16(SkPMColor src)
00149 {
00150 <span class="preprocessor">#if 0</span>
00151 <span class="preprocessor"></span>        <span class="keywordflow">return</span>  (SkPacked32ToR16(src) &lt;&lt; SK_R16_SHIFT) |
00152                         (SkPacked32ToG16(src) &lt;&lt; SK_G16_SHIFT) |
00153                         (SkPacked32ToB16(src) &lt;&lt; SK_B16_SHIFT);
00154 <span class="preprocessor">#else   // only works if the components are in the same order in both formats (i.e. foo32_shift &gt;= foo16_shift)</span>
00155 <span class="preprocessor"></span>        <span class="keywordflow">return</span>  ((src &gt;&gt; (SK_R32_SHIFT + SK_R32_BITS - SK_R16_BITS - SK_R16_SHIFT)) &amp; (SK_R16_MASK &lt;&lt; SK_R16_SHIFT)) |
00156                         ((src &gt;&gt; (SK_G32_SHIFT + SK_G32_BITS - SK_G16_BITS - SK_G16_SHIFT)) &amp; (SK_G16_MASK &lt;&lt; SK_G16_SHIFT)) |
00157                         ((src &gt;&gt; (SK_B32_SHIFT + SK_B32_BITS - SK_B16_BITS - SK_B16_SHIFT)) &amp; (SK_B16_MASK &lt;&lt; SK_B16_SHIFT));
00158 <span class="preprocessor">#endif</span>
00159 <span class="preprocessor"></span>}
00160 
00161 <span class="preprocessor">#define SkPixel32ToPixel16_ToU16(src)   SkToU16(SkPixel32ToPixel16(src))</span>
00162 <span class="preprocessor"></span>
00164 <span class="comment">// Convert a 16bit pixel to a 32bit pixel</span>
00165 
00166 <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> SkR16ToR32(<span class="keywordtype">unsigned</span> r)
00167 {
00168         <span class="keywordflow">return</span> (r &lt;&lt; (8 - SK_R16_BITS)) | (r &gt;&gt; (2 * SK_R16_BITS - 8));
00169 }
00170 <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> SkG16ToG32(<span class="keywordtype">unsigned</span> g)
00171 {
00172         <span class="keywordflow">return</span> (g &lt;&lt; (8 - SK_G16_BITS)) | (g &gt;&gt; (2 * SK_G16_BITS - 8));
00173 }
00174 <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> SkB16ToB32(<span class="keywordtype">unsigned</span> b)
00175 {
00176         <span class="keywordflow">return</span> (b &lt;&lt; (8 - SK_B16_BITS)) | (b &gt;&gt; (2 * SK_B16_BITS - 8));
00177 }
00178 
00179 <span class="preprocessor">#define SkPacked16ToR32(c)              SkR16ToR32(SkGetPackedR16(c))</span>
00180 <span class="preprocessor"></span><span class="preprocessor">#define SkPacked16ToG32(c)              SkG16ToG32(SkGetPackedG16(c))</span>
00181 <span class="preprocessor"></span><span class="preprocessor">#define SkPacked16ToB32(c)              SkB16ToB32(SkGetPackedB16(c))</span>
00182 <span class="preprocessor"></span>
00183 <span class="keyword">inline</span> <a class="code" href="SkColor_8h.html#a18">SkPMColor</a> SkPixel16ToPixel32(U16CPU src)
00184 {
00185         SkASSERT(src == SkToU16(src));
00186 
00187         <span class="keywordtype">unsigned</span>        r = SkPacked16ToR32(src);
00188         <span class="keywordtype">unsigned</span>        g = SkPacked16ToG32(src);
00189         <span class="keywordtype">unsigned</span>        b = SkPacked16ToB32(src);
00190 
00191         SkASSERT((r &gt;&gt; (8 - SK_R16_BITS)) == SkGetPackedR16(src));
00192         SkASSERT((g &gt;&gt; (8 - SK_G16_BITS)) == SkGetPackedG16(src));
00193         SkASSERT((b &gt;&gt; (8 - SK_B16_BITS)) == SkGetPackedB16(src));
00194 
00195         <span class="keywordflow">return</span> SkPackARGB32(0xFF, r, g, b);
00196 }
00197 
00198 <span class="preprocessor">#endif</span>
00199 <span class="preprocessor"></span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue May 9 14:35:23 2006 for SGL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.0 </small></address>
</body>
</html>
