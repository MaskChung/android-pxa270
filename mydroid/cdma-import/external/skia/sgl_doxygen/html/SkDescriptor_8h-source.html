<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SGL: SkDescriptor.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.0 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">skia</a></div>
<h1>SkDescriptor.h</h1><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#ifndef SkDescriptor_DEFINED</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define SkDescriptor_DEFINED</span>
00003 <span class="preprocessor"></span>
00004 <span class="preprocessor">#include "SkTypes.h"</span>
00005 
00006 <span class="keyword">class </span>SkDescriptor {
00007 <span class="keyword">public</span>:
00008         <span class="keyword">static</span> size_t ComputeOverhead(<span class="keywordtype">int</span> entryCount)
00009         {
00010                 SkASSERT(entryCount &gt;= 0);
00011                 <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(SkDescriptor) + entryCount * <span class="keyword">sizeof</span>(Entry);
00012         }
00013 
00014         <span class="keyword">static</span> SkDescriptor* Alloc(size_t length)
00015         {
00016                 SkASSERT(SkAlign4(length) == length);
00017                 SkDescriptor* desc = (SkDescriptor*)sk_malloc_throw(length);
00018                 <span class="keywordflow">return</span> desc;
00019         }
00020 
00021         <span class="keyword">static</span> <span class="keywordtype">void</span> Free(SkDescriptor* desc)
00022         {
00023                 sk_free(desc);
00024         }
00025 
00026         <span class="keywordtype">void</span> init()
00027         {
00028                 fLength = <span class="keyword">sizeof</span>(SkDescriptor);
00029                 fCount  = 0;
00030         }
00031 
00032         U32 getLength()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fLength; }
00033 
00034         <span class="keywordtype">void</span>* addEntry(U32 tag, U32 length, <span class="keyword">const</span> <span class="keywordtype">void</span>* data = nil)
00035         {
00036                 SkASSERT(tag);
00037                 SkASSERT(SkAlign4(length) == length);
00038                 SkASSERT(this-&gt;findEntry(tag, nil) == nil);
00039 
00040                 Entry*  entry = (Entry*)((<span class="keywordtype">char</span>*)<span class="keyword">this</span> + fLength);
00041                 entry-&gt;fTag = tag;
00042                 entry-&gt;fLen = length;
00043                 <span class="keywordflow">if</span> (data)
00044                         memcpy(entry + 1, data, length);
00045 
00046                 fCount += 1;
00047                 fLength += sizeof(Entry) + length;
00048                 return (entry + 1);     <span class="comment">// return its data</span>
00049         }
00050 
00051         <span class="keywordtype">void</span> computeChecksum()
00052         {
00053                 fChecksum = SkDescriptor::ComputeChecksum(<span class="keyword">this</span>);
00054         }
00055 
00056 <span class="preprocessor">#ifdef SK_DEBUG</span>
00057 <span class="preprocessor"></span>        <span class="keywordtype">void</span> assertChecksum()<span class="keyword"> const</span>
00058 <span class="keyword">        </span>{
00059                 SkASSERT(fChecksum == SkDescriptor::ComputeChecksum(<span class="keyword">this</span>));
00060         }
00061 <span class="preprocessor">#endif</span>
00062 <span class="preprocessor"></span>
00063         <span class="keyword">const</span> <span class="keywordtype">void</span>* findEntry(U32 tag, U32* length)<span class="keyword"> const</span>
00064 <span class="keyword">        </span>{
00065                 <span class="keyword">const</span> Entry* entry = (<span class="keyword">const</span> Entry*)(<span class="keyword">this</span> + 1);
00066                 <span class="keywordtype">int</span>                      count = fCount;
00067 
00068                 <span class="keywordflow">while</span> (--count &gt;= 0)
00069                 {
00070                         <span class="keywordflow">if</span> (entry-&gt;fTag == tag)
00071                         {
00072                                 <span class="keywordflow">if</span> (length)
00073                                         *length = entry-&gt;fLen;
00074                                 <span class="keywordflow">return</span> entry + 1;
00075                         }
00076                         entry = (<span class="keyword">const</span> Entry*)((<span class="keyword">const</span> <span class="keywordtype">char</span>*)(entry + 1) + entry-&gt;fLen);
00077                 }
00078                 <span class="keywordflow">return</span> nil;
00079         }
00080 
00081         SkDescriptor* copy()<span class="keyword"> const</span>
00082 <span class="keyword">        </span>{
00083                 SkDescriptor* desc = SkDescriptor::Alloc(fLength);
00084                 memcpy(desc, <span class="keyword">this</span>, fLength);
00085                 <span class="keywordflow">return</span> desc;
00086         }
00087 
00088         <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> SkDescriptor&amp; a, <span class="keyword">const</span> SkDescriptor&amp; b)
00089         {
00090                 <span class="keywordflow">return</span>  a.fChecksum == b.fChecksum &amp;&amp;
00091                                 a.fLength == b.fLength &amp;&amp;
00092                                 <span class="comment">// this assumes that fCount is the beginning of the rest of the descriptor</span>
00093                                 <span class="comment">// (after fCheckSum and fLength)</span>
00094                                 memcmp(&amp;a.fCount, &amp;b.fCount, a.fLength - 2*<span class="keyword">sizeof</span>(U32)) == 0;
00095         }
00096 
00097         <span class="keyword">struct </span>Entry {
00098                 U32     fTag;
00099                 U32     fLen;
00100         };
00101 
00102 <span class="preprocessor">#ifdef SK_DEBUG</span>
00103 <span class="preprocessor"></span>        U32 getChecksum()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fChecksum; }
00104         U32 getCount()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fCount; }
00105 <span class="preprocessor">#endif</span>
00106 <span class="preprocessor"></span>
00107 <span class="keyword">private</span>:
00108         U32     fChecksum;      <span class="comment">// must be first</span>
00109         U32     fLength;        <span class="comment">// must be second</span>
00110         U32     fCount;
00111 
00112         <span class="keyword">static</span> U32 ComputeChecksum(<span class="keyword">const</span> SkDescriptor* desc)
00113         {
00114                 <span class="keyword">const</span> U32*      ptr = (<span class="keyword">const</span> U32*)desc + 1;     <span class="comment">// skip the checksum field</span>
00115                 <span class="keyword">const</span> U32*      stop = (<span class="keyword">const</span> U32*)((<span class="keyword">const</span> <span class="keywordtype">char</span>*)desc + desc-&gt;fLength);
00116                 U32                     sum = 0;
00117 
00118                 SkASSERT(ptr &lt; stop);
00119                 <span class="keywordflow">do</span> {
00120                         sum = (sum &lt;&lt; 1) | (sum &gt;&gt; 31);
00121                         sum += *ptr++;
00122                 } <span class="keywordflow">while</span> (ptr &lt; stop);
00123 
00124                 <span class="keywordflow">return</span> sum;
00125         }
00126 };
00127 
00128 <span class="preprocessor">#endif</span>
00129 <span class="preprocessor"></span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue May 9 14:35:23 2006 for SGL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.0 </small></address>
</body>
</html>
