<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SGL: SkDeque.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.0 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">skia</a></div>
<h1>SkDeque.h</h1><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#ifndef SkTDeque_DEFINED</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define SkTDeque_DEFINED</span>
00003 <span class="preprocessor"></span>
00004 <span class="preprocessor">#include "SkTypes.h"</span>
00005 
00006 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>sk_trait_trivial_constructor  { <span class="keyword">enum</span> { value = <span class="keyword">false</span> }; };
00007 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>sk_trait_trivial_destructor   { <span class="keyword">enum</span> { value = <span class="keyword">false</span> }; };
00008 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>sk_trait_trivial_copy         { <span class="keyword">enum</span> { value = <span class="keyword">false</span> }; };
00009 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>sk_trait_trivial_assign       { <span class="keyword">enum</span> { value = <span class="keyword">false</span> }; };
00010 
00011 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>sk_traits {
00012     <span class="keyword">enum</span> {
00013         has_trivial_constructor = sk_trait_trivial_constructor&lt;T&gt;::value,
00014         has_trivial_destructor  = sk_trait_trivial_destructor&lt;T&gt;::value,
00015         has_trivial_copy        = sk_trait_trivial_copy&lt;T&gt;::value,
00016         has_trivial_assign      = sk_trait_trivial_assign&lt;T&gt;::value
00017     };
00018 };
00019 
00020 <span class="preprocessor">#define SK_SET_BASIC_TRAITS(T)                                                  \</span>
00021 <span class="preprocessor">    template &lt;&gt; struct sk_trait_trivial_constructor&lt;T&gt; { enum { value = true }; };     \</span>
00022 <span class="preprocessor">    template &lt;&gt; struct sk_trait_trivial_destructor&lt;T&gt;  { enum { value = true }; };     \</span>
00023 <span class="preprocessor">    template &lt;&gt; struct sk_trait_trivial_copy&lt;T&gt;        { enum { value = true }; };     \</span>
00024 <span class="preprocessor">    template &lt;&gt; struct sk_trait_trivial_assign&lt;T&gt;      { enum { value = true }; }</span>
00025 <span class="preprocessor"></span>
00026 <span class="preprocessor">#define SK_SET_TYPE_TRAITS(T, ctor, dtor, copy, asgn)                           \</span>
00027 <span class="preprocessor">    template &lt;&gt; struct sk_trait_trivial_constructor&lt;T&gt; { enum { value = ctor }; };     \</span>
00028 <span class="preprocessor">    template &lt;&gt; struct sk_trait_trivial_destructor&lt;T&gt;  { enum { value = dtor }; };     \</span>
00029 <span class="preprocessor">    template &lt;&gt; struct sk_trait_trivial_copy&lt;T&gt;        { enum { value = copy }; };     \</span>
00030 <span class="preprocessor">    template &lt;&gt; struct sk_trait_trivial_assign&lt;T&gt;      { enum { value = asgn }; }</span>
00031 <span class="preprocessor"></span>
00032 <span class="preprocessor">#include &lt;new&gt;</span>
00033 
00034 <span class="keyword">class </span>SkDeque {
00035 <span class="keyword">public</span>:
00036     SkDeque(size_t elemSize);
00037     SkDeque(size_t elemSize, <span class="keywordtype">void</span>* storage, size_t storageSize);
00038     ~SkDeque();
00039 
00040     <span class="keywordtype">bool</span>    empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fCount == 0; }
00041     <span class="keywordtype">int</span>     count()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fCount; }
00042 
00043     <span class="keyword">const</span> <span class="keywordtype">void</span>* front() <span class="keyword">const</span>;
00044     <span class="keyword">const</span> <span class="keywordtype">void</span>* back() <span class="keyword">const</span>;
00045 
00046     <span class="keywordtype">void</span>* front()
00047     {
00048         <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*)((<span class="keyword">const</span> SkDeque*)<span class="keyword">this</span>)-&gt;front();
00049     }
00050     <span class="keywordtype">void</span>* back()
00051     {
00052         <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*)((<span class="keyword">const</span> SkDeque*)<span class="keyword">this</span>)-&gt;back();
00053     }
00054 
00055     <span class="keywordtype">void</span>*   push_front();
00056     <span class="keywordtype">void</span>*   push_back();
00057     
00058     <span class="keywordtype">void</span>    pop_front();
00059     <span class="keywordtype">void</span>    pop_back();
00060     
00061     SkDEBUGCODE(<span class="keyword">static</span> <span class="keywordtype">void</span> UnitTest();)
00062 
00063 <span class="keyword">private</span>:
00064     <span class="keyword">struct </span>Head;
00065 
00066 <span class="keyword">public</span>:
00067     <span class="keyword">class </span>Iter {
00068     <span class="keyword">public</span>:
00069         Iter(<span class="keyword">const</span> SkDeque&amp; d);
00070         <span class="keywordtype">void</span>* next();
00071 
00072     <span class="keyword">private</span>:
00073         SkDeque::Head*  fHead;
00074         <span class="keywordtype">char</span>*           fPos;
00075         size_t          fElemSize;
00076     };
00077 
00078 <span class="keyword">private</span>:
00079     Head*   fFront;
00080     Head*   fBack;
00081     size_t  fElemSize;
00082     <span class="keywordtype">void</span>*   fInitialStorage;
00083     <span class="keywordtype">int</span>     fCount;
00084     
00085     <span class="keyword">friend</span> <span class="keyword">class </span>Iter;
00086 };
00087 
00088 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>SkTDeque {
00089 <span class="keyword">public</span>:
00090     SkTDeque() : fD(sizeof(T)) {}
00091     SkTDeque(T storage[], <span class="keywordtype">int</span> count) : fD(sizeof(T), storage, count * sizeof(T)) {}
00092     <span class="keyword">inline</span> ~SkTDeque();
00093 
00094     <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fD.empty(); }
00095     <span class="keywordtype">int</span> count()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fD.count(); }
00096 
00097     T*          front() { <span class="keywordflow">return</span> (T*)fD.front(); }
00098     const T*    front()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (<span class="keyword">const</span> T*)fD.front(); }
00099     T*          back() { <span class="keywordflow">return</span> (T*)fD.back(); }
00100     const T*    back()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (<span class="keyword">const</span> T*)fD.back(); }
00101     
00102     T* push_front()
00103     {
00104         T* front = (T*)fD.push_front();
00105         <span class="keywordflow">if</span> (!sk_traits&lt;T&gt;::has_trivial_constructor) {
00106             <span class="keyword">new</span>(front) T();
00107         }
00108         <span class="keywordflow">return</span> front;
00109     }
00110     T* push_back()
00111     {
00112         T* back = (T*)fD.push_back();
00113         <span class="keywordflow">if</span> (!sk_traits&lt;T&gt;::has_trivial_constructor) {
00114             <span class="keyword">new</span>(back) T();
00115         }
00116         <span class="keywordflow">return</span> back;
00117     }
00118 
00119     T* push_front(<span class="keyword">const</span> T&amp; value)
00120     {
00121         T* front = (T*)fD.push_front();
00122         <span class="keywordflow">if</span> (sk_traits&lt;T&gt;::has_trivial_copy) {
00123             *front = value;
00124         }
00125         <span class="keywordflow">else</span> {
00126             <span class="keyword">new</span>(front) T(value);
00127         }
00128         <span class="keywordflow">return</span> front;
00129     }
00130     T* push_back(<span class="keyword">const</span> T&amp; value)
00131     {
00132         T* back = (T*)fD.push_back();
00133         <span class="keywordflow">if</span> (sk_traits&lt;T&gt;::has_trivial_copy) {
00134             *back = value;
00135         }
00136         <span class="keywordflow">else</span> {
00137             <span class="keyword">new</span>(back) T(value);
00138         }
00139         <span class="keywordflow">return</span> back;
00140     }
00141     
00142     <span class="keywordtype">void</span> pop_front()
00143     {
00144         <span class="keywordflow">if</span> (!sk_traits&lt;T&gt;::has_trivial_destructor) {
00145             this-&gt;front()-&gt;~T();
00146         }
00147         fD.pop_front();
00148     }
00149     <span class="keywordtype">void</span> pop_back()
00150     {
00151         <span class="keywordflow">if</span> (!sk_traits&lt;T&gt;::has_trivial_destructor) {
00152             this-&gt;back()-&gt;~T();
00153         }
00154         fD.pop_back();
00155     }
00156     
00157     <span class="keyword">class </span>Iter : <span class="keyword">private</span> SkDeque::Iter {
00158     <span class="keyword">public</span>:
00159         Iter(<span class="keyword">const</span> SkTDeque&lt;T&gt;&amp; d) : SkDeque::Iter(d.fD) {}
00160         T* next() { <span class="keywordflow">return</span> (T*)SkDeque::Iter::next(); }
00161     };
00162 
00163 private:
00164     SkDeque fD;
00165 };
00166 
00167 template &lt;size_t COUNT, typename T&gt; class SkSTDeque : public SkTDeque&lt;T&gt; {
00168 <span class="keyword">public</span>:
00169     SkSTDeque() : SkTDeque&lt;T&gt;((T*)fStorage, COUNT) {}
00170     
00171 <span class="keyword">private</span>:
00172     uint32_t fStorage[SkAlign4(COUNT * <span class="keyword">sizeof</span>(T))];
00173 };
00174 
00176 
00177 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> SkTDeque&lt;T&gt;::~SkTDeque()
00178 {
00179     <span class="keywordflow">if</span> (!sk_traits&lt;T&gt;::has_trivial_destructor)
00180     {
00181         Iter   iter(*<span class="keyword">this</span>);
00182         T*     t;
00183         <span class="keywordflow">while</span> ((t = iter.next()) != nil) {
00184             t-&gt;~T();
00185         }
00186     }
00187 }
00188 
00189 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue May 9 14:35:23 2006 for SGL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.0 </small></address>
</body>
</html>
