<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SGL: SkTDArray.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.0 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">include</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">skia</a></div>
<h1>SkTDArray.h</h1><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#ifndef SkTDArray_DEFINED</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define SkTDArray_DEFINED</span>
00003 <span class="preprocessor"></span>
00004 <span class="preprocessor">#include "SkTypes.h"</span>
00005 
00006 <span class="preprocessor">#ifdef SK_DEBUG</span>
00007 <span class="preprocessor"></span><span class="preprocessor">#define kDebugArraySize 16</span>
00008 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00009 <span class="preprocessor"></span>
00010 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class </span>SkTDArray {
00011 <span class="keyword">public</span>:
00012         SkTDArray()
00013         {
00014                 fReserve = fCount = 0;
00015                 fArray = nil;
00016 <span class="preprocessor">#ifdef SK_DEBUG</span>
00017 <span class="preprocessor"></span>                fData = nil;
00018 <span class="preprocessor">#endif</span>
00019 <span class="preprocessor"></span>        }
00020         SkTDArray(<span class="keyword">const</span> T src[], U16CPU count)
00021         {
00022                 SkASSERT(src || count == 0);
00023 
00024                 fReserve = fCount = 0;
00025                 fArray = nil;
00026 <span class="preprocessor">#ifdef SK_DEBUG</span>
00027 <span class="preprocessor"></span>                fData = nil;
00028 <span class="preprocessor">#endif</span>
00029 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (count)
00030                 {
00031                         fArray = (T*)sk_malloc_throw(count * <span class="keyword">sizeof</span>(T));
00032 <span class="preprocessor">#ifdef SK_DEBUG</span>
00033 <span class="preprocessor"></span>                        fData = (T (*)[kDebugArraySize]) fArray;
00034 <span class="preprocessor">#endif</span>
00035 <span class="preprocessor"></span>                        memcpy(fArray, src, <span class="keyword">sizeof</span>(T) * count);
00036                         fReserve = fCount = SkToU16(count);
00037                 }
00038         }
00039         SkTDArray(<span class="keyword">const</span> SkTDArray&lt;T&gt;&amp; src)
00040         {
00041                 fReserve = fCount = 0;
00042                 fArray = nil;
00043 <span class="preprocessor">#ifdef SK_DEBUG</span>
00044 <span class="preprocessor"></span>                fData = nil;
00045 <span class="preprocessor">#endif</span>
00046 <span class="preprocessor"></span>                SkTDArray&lt;T&gt; tmp(src.fArray, src.fCount);
00047                 this-&gt;swap(tmp);
00048         }
00049         ~SkTDArray()
00050         {
00051                 sk_free(fArray);
00052         }
00053 
00054         SkTDArray&lt;T&gt;&amp; operator=(<span class="keyword">const</span> SkTDArray&lt;T&gt;&amp; src)
00055         {
00056                 <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;src)
00057                 {
00058                         <span class="keywordflow">if</span> (src.fCount &gt; fReserve)
00059                         {
00060                                 SkTDArray&lt;T&gt; tmp(src.fArray, src.fCount);
00061                                 this-&gt;swap(tmp);
00062                         }
00063                         <span class="keywordflow">else</span>
00064                         {
00065                                 memcpy(fArray, src.fArray, <span class="keyword">sizeof</span>(T) * src.fCount);
00066                                 fCount = src.fCount;
00067                         }
00068                 }
00069                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00070         }
00071 
00072         <span class="keyword">friend</span> <span class="keywordtype">int</span> operator==(<span class="keyword">const</span> SkTDArray&lt;T&gt;&amp; a, <span class="keyword">const</span> SkTDArray&lt;T&gt;&amp; b)
00073         {
00074                 <span class="keywordflow">return</span>  a.fCount == b.fCount &amp;&amp;
00075                                 (a.fCount == 0 || !memcmp(a.fArray, b.fArray, a.fCount * <span class="keyword">sizeof</span>(T)));
00076         }
00077 
00078         <span class="keywordtype">void</span> swap(SkTDArray&lt;T&gt;&amp; other)
00079         {
00080                 SkTSwap(fArray, other.fArray);
00081 <span class="preprocessor">#ifdef SK_DEBUG</span>
00082 <span class="preprocessor"></span>                SkTSwap(fData, other.fData);
00083 <span class="preprocessor">#endif</span>
00084 <span class="preprocessor"></span>                SkTSwap(fReserve, other.fReserve);
00085                 SkTSwap(fCount, other.fCount);
00086         }
00087 
00088         <span class="keywordtype">bool</span> isEmpty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fCount == 0; }
00089         <span class="keywordtype">int</span>     count()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fCount; }
00090         T*      begin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fArray; }
00091         T*      end()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> fArray ? fArray + fCount : nil; }
00092         T&amp;      operator[](<span class="keywordtype">int</span> index)<span class="keyword"> const </span>{ SkASSERT((<span class="keywordtype">unsigned</span>)index &lt; fCount); <span class="keywordflow">return</span> fArray[index]; }
00093 
00094         <span class="keywordtype">void</span> reset()
00095         {
00096                 <span class="keywordflow">if</span> (fArray)
00097                 {
00098                         sk_free(fArray);
00099                         fArray = nil;
00100 <span class="preprocessor">#ifdef SK_DEBUG</span>
00101 <span class="preprocessor"></span>                        fData = nil;
00102 <span class="preprocessor">#endif</span>
00103 <span class="preprocessor"></span>                        fReserve = fCount = 0;
00104                 }
00105                 <span class="keywordflow">else</span>
00106                 {
00107                         SkASSERT(fReserve == 0 &amp;&amp; fCount == 0);
00108                 }
00109         }
00110 
00111         <span class="keywordtype">void</span> setCount(U16CPU count)
00112         {
00113                 <span class="keywordflow">if</span> (count &gt; fReserve)
00114                         this-&gt;growBy(count - fCount);
00115                 else
00116                         fCount = SkToU16(count);
00117         }
00118 
00119         <span class="keywordtype">void</span> setReserve(U16CPU reserve)
00120         {
00121                 <span class="keywordflow">if</span> (reserve &gt; fReserve)
00122                 {
00123                         SkASSERT(reserve &gt; fCount);
00124                         U16     count = fCount;
00125                         this-&gt;growBy(reserve - fCount);
00126                         fCount = count;
00127                 }
00128         }
00129 
00130         T* prepend()
00131         {
00132                 this-&gt;growBy(1);
00133                 memmove(fArray + 1, fArray, (fCount - 1) * <span class="keyword">sizeof</span>(T));
00134                 <span class="keywordflow">return</span> fArray;
00135         }
00136 
00137         T* append() { <span class="keywordflow">return</span> this-&gt;append(1, nil); }
00138         T* append(U16CPU count, <span class="keyword">const</span> T* src = nil)
00139         {
00140                 <span class="keywordtype">unsigned</span> oldCount = fCount;
00141                 <span class="keywordflow">if</span> (count)
00142                 {
00143                         SkASSERT(src == nil || fArray == nil ||
00144                                         src + count &lt;= fArray || fArray + oldCount &lt;= src);
00145 
00146                         this-&gt;growBy(count);
00147                         <span class="keywordflow">if</span> (src)
00148                                 memcpy(fArray + oldCount, src, sizeof(T) * count);
00149                 }
00150                 return fArray + oldCount;
00151         }
00152         
00153         T* appendClear()
00154         {
00155                 T* result = this-&gt;append(); 
00156                 *result = 0;
00157                 <span class="keywordflow">return</span> result;
00158         }
00159 
00160         T* insert(U16CPU index) { <span class="keywordflow">return</span> this-&gt;insert(index, 1, nil); }
00161         T* insert(U16CPU index, U16CPU count, <span class="keyword">const</span> T* src = nil)
00162         {
00163                 SkASSERT(count);
00164                 <span class="keywordtype">int</span> oldCount = fCount;
00165                 this-&gt;growBy(count);
00166                 T* dst = fArray + index;
00167                 memmove(dst + count, dst, <span class="keyword">sizeof</span>(T) * (oldCount - index));
00168                 <span class="keywordflow">if</span> (src)
00169                         memcpy(dst, src, sizeof(T) * count);
00170                 return dst;
00171         }
00172 
00173         <span class="keywordtype">void</span> remove(U16CPU index, U16CPU count = 1)
00174         {
00175                 SkASSERT(index + count &lt;= fCount);
00176                 fCount = SkToU16(fCount - count);
00177                 memmove(fArray + index, fArray + index + count, <span class="keyword">sizeof</span>(T) * (fCount - index));
00178         }
00179 
00180         <span class="keywordtype">void</span> removeShuffle(U16CPU index)
00181         {
00182                 SkASSERT(index &lt; fCount);
00183                 <span class="keywordtype">unsigned</span> newCount = fCount - 1;
00184                 fCount = SkToU16(newCount);
00185                 <span class="keywordflow">if</span> (index != newCount)
00186                         memcpy(fArray + index, fArray + newCount, sizeof(T));
00187         }
00188 
00189         <span class="keywordtype">int</span> find(const T&amp; elem)<span class="keyword"> const</span>
00190 <span class="keyword">        </span>{
00191                 <span class="keyword">const</span> T* iter = fArray;
00192                 <span class="keyword">const</span> T* stop = fArray + fCount;
00193 
00194                 <span class="keywordflow">for</span> (; iter &lt; stop; iter++)
00195                 {
00196                         <span class="keywordflow">if</span> (*iter == elem)
00197                                 return (<span class="keywordtype">int</span>) (iter - fArray);
00198                 }
00199                 return -1;
00200         }
00201 
00202         <span class="keywordtype">int</span> rfind(const T&amp; elem)<span class="keyword"> const</span>
00203 <span class="keyword">        </span>{
00204                 <span class="keyword">const</span> T* iter = fArray + fCount;
00205                 <span class="keyword">const</span> T* stop = fArray;
00206 
00207                 <span class="keywordflow">while</span> (iter &gt; stop)
00208                 {
00209                         <span class="keywordflow">if</span> (*--iter == elem)
00210                                 return iter - stop;
00211                 }
00212                 return -1;
00213         }
00214 
00215         <span class="comment">// routines to treat the array like a stack</span>
00216         T*                      push() { <span class="keywordflow">return</span> this-&gt;append(); }
00217         <span class="keywordtype">void</span>            push(T&amp; elem) { *this-&gt;append() = elem; }
00218         <span class="keyword">const</span> T&amp;        top()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (*<span class="keyword">this</span>)[fCount - 1]; }
00219         T&amp;                      top() { <span class="keywordflow">return</span> (*<span class="keyword">this</span>)[fCount - 1]; }
00220         <span class="keywordtype">void</span>            pop(T* elem) { <span class="keywordflow">if</span> (elem) *elem = (*this)[fCount - 1]; --fCount; }
00221         <span class="keywordtype">void</span>            pop() { --fCount; }
00222 
00223         <span class="keywordtype">void</span> deleteAll()
00224         {
00225                 T*      iter = fArray;
00226                 T*      stop = fArray + fCount;
00227                 <span class="keywordflow">while</span> (iter &lt; stop)
00228                 {
00229                         <span class="keyword">delete</span> (*iter);
00230                         iter += 1;
00231                 }
00232                 this-&gt;reset();
00233         }
00234 
00235         <span class="keywordtype">void</span> freeAll()
00236         {
00237                 T*      iter = fArray;
00238                 T*      stop = fArray + fCount;
00239                 <span class="keywordflow">while</span> (iter &lt; stop)
00240                 {
00241                         sk_free(*iter);
00242                         iter += 1;
00243                 }
00244                 this-&gt;reset();
00245         }
00246 
00247         <span class="keywordtype">void</span> unrefAll()
00248         {
00249                 T*      iter = fArray;
00250                 T*      stop = fArray + fCount;
00251                 <span class="keywordflow">while</span> (iter &lt; stop)
00252                 {
00253                         (*iter)-&gt;unref();
00254                         iter += 1;
00255                 }
00256                 this-&gt;reset();
00257         }
00258 
00259 <span class="keyword">private</span>:
00260 <span class="preprocessor">#ifdef SK_DEBUG</span>
00261 <span class="preprocessor"></span>        T(* fData)[kDebugArraySize];
00262 <span class="preprocessor">#endif</span>
00263 <span class="preprocessor"></span>        T*      fArray;
00264         U16     fReserve, fCount;
00265 
00266         <span class="keywordtype">void</span> growBy(U16CPU extra)
00267         {
00268                 SkASSERT(extra);
00269                 SkASSERT(fCount + extra &lt;= 0xFFFF);
00270 
00271                 <span class="keywordflow">if</span> (fCount + extra &gt; fReserve)
00272                 {
00273                         size_t size = fCount + extra + 4;
00274                         size += size &gt;&gt; 2;
00275 
00276                         fArray = (T*)sk_realloc_throw(fArray, size * <span class="keyword">sizeof</span>(T));
00277 <span class="preprocessor">#ifdef SK_DEBUG</span>
00278 <span class="preprocessor"></span>                        fData = (T (*)[kDebugArraySize]) fArray;
00279 <span class="preprocessor">#endif</span>
00280 <span class="preprocessor"></span>                        fReserve = SkToU16((U16CPU)size);
00281                 }
00282                 fCount = SkToU16(fCount + extra);
00283         }
00284 };
00285 
00286 <span class="preprocessor">#endif</span>
00287 <span class="preprocessor"></span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue May 9 14:35:23 2006 for SGL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.0 </small></address>
</body>
</html>
