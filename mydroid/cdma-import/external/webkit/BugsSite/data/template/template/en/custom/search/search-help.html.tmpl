#------------------------------------------------------------------------
# Compiled template generated by the Template Toolkit version 2.15
#------------------------------------------------------------------------

Template::Document->new({
    METADATA => {
        'modtime' => '1138010588',
        'name' => 'search/search-help.html.tmpl',
    },
    BLOCK => sub {
        my $context = shift || die "template sub called without context\n";
        my $stash   = $context->stash;
        my $output  = '';
        my $error;
        
        eval { BLOCK: {
    $output .=  "\n";
    $output .=  "\n  ";
    #line 1 "template/en/custom/search/search-help.html.tmpl"
    $stash->set('help_html', [ { 'id' => 'short_desc_type', 'html' => 'The type of summary search you would like'  }, { 'id' => 'short_desc', 'html' => ("The " . $stash->get(['terms', 0, 'bug', 0]) . " summary is a short sentence which succinctly  \n           describes <br> what the " . $stash->get(['terms', 0, 'bug', 0]) . " is about.")  }, { 'id' => 'classification', 'html' => ($stash->get(['terms', 0, 'Bugs', 0]) . " are categorised into Classifications, Products and Components. classifications is the<br>\n           top-level categorisation.")  }, { 'id' => 'product', 'html' => $stash->get(['Param', [ 'useclassification' ]]) ? ($stash->get(['terms', 0, 'Bugs', 0]) . " are categorised into Products and Components. Select a Classification to narrow down this list") : ($stash->get(['terms', 0, 'Bugs', 0]) . " are categorised into Products and Components. Product is \n           the<br>top-level categorisation.")  }, { 'id' => 'component', 'html' => 'Components are second-level categories; each belongs to a<br> 
               particular Product. Select a Product to narrow down this list.'  }, { 'id' => 'version', 'html' => ("The version field defines the version of the software the \n           " . $stash->get(['terms', 0, 'bug', 0]) . "<br>was found in.")  }, { 'id' => 'target_milestone', 'html' => ("The target_milestone field is used to define when the engineer<br>\n           the " . $stash->get(['terms', 0, 'bug', 0]) . " is assigned to expects to fix it.")  }, { 'id' => 'long_desc', 'html' => ($stash->get(['terms', 0, 'Bugs', 0]) . " have comments added to them by " . $stash->get(['terms', 0, 'Bugzilla', 0]) . " users.  \n           You can<br>search for some text in those comments.")  }, { 'id' => 'long_desc_type', 'html' => 'The type of comment search you would like'  }, { 'id' => 'bug_file_loc', 'html' => ($stash->get(['terms', 0, 'Bugs', 0]) . " can have a URL associated with them - for example, a \n           pointer<br>to a web site where the problem is seen.")  }, { 'id' => 'bug_file_loc_type', 'html' => 'The type of URL search you would like'  }, { 'id' => 'status_whiteboard', 'html' => ("Each " . $stash->get(['terms', 0, 'bug', 0]) . " has a free-form single line text entry box for \n           adding<br>tags and status information.")  }, { 'id' => 'status_whiteboard_type', 'html' => 'The type of whiteboard search you would like'  }, { 'id' => 'keywords', 'html' => ("You can add keywords from a defined list to " . $stash->get(['terms', 0, 'bugs', 0]) . ", in order \n           to<br>tag and group them.")  }, { 'id' => 'keywords_type', 'html' => 'The type of keyword search you would like'  }, { 'id' => 'bug_status', 'html' => ("A " . $stash->get(['terms', 0, 'bug', 0]) . " may be in any of a number of states.")  }, { 'id' => 'resolution', 'html' => ("If a " . $stash->get(['terms', 0, 'bug', 0]) . " is in a resolved state, then one of these reasons \n           will<br>be given for its resolution.")  }, { 'id' => 'bug_severity', 'html' => ("How severe the " . $stash->get(['terms', 0, 'bug', 0]) . " is, or whether it's an enhancement.")  }, { 'id' => 'priority', 'html' => ("Engineers prioritise their " . $stash->get(['terms', 0, 'bugs', 0]) . " using this field.")  }, { 'id' => 'rep_platform', 'html' => ("The hardware platform the " . $stash->get(['terms', 0, 'bug', 0]) . " was observed on.")  }, { 'id' => 'op_sys', 'html' => ("The operating system the " . $stash->get(['terms', 0, 'bug', 0]) . " was observed on.")  }, { 'id' => 'email1', 'html' => ("Every " . $stash->get(['terms', 0, 'bug', 0]) . " has people associated with it in different \n           roles.<br>Here, you can search on what people are in what role.")  }, { 'id' => 'email2', 'html' => ("Every " . $stash->get(['terms', 0, 'bug', 0]) . " has people associated with it in different \n           roles.<br>Here, you can search on what people are in what role.")  }, { 'id' => 'bug_id', 'html' => ("You can limit your search to a specific set of " . $stash->get(['terms', 0, 'bugs', 0]) . " .")  }, { 'id' => 'votes', 'html' => ("Some " . $stash->get(['terms', 0, 'bugs', 0]) . " can be voted for, and you can limit your search to \n           " . $stash->get(['terms', 0, 'bugs', 0]) . "<br>with more than a certain number of votes.")  }, { 'id' => 'chfield', 'html' => 'You can search for specific types of change - this field define <br>
               which field you are interested in changes for.'  }, { 'id' => 'chfieldfrom', 'html' => 'Specify the start and end dates either in YYYY-MM-DD format<br>
               (optionally followed by HH:mm, in 24 hour clock), or in relative<br>
               dates such as 1d, 2w, 3m, 4y, which respectively mean one day,<br>
               two weeks, three months, or four years ago. 0d is last midnight,<br>
               and 0w, 0m, 0y is the beginning of this week, month, or year.'  }, { 'id' => 'chfieldto', 'html' => 'Specify the start and end dates either in YYYY-MM-DD format<br>
               (optionally followed by HH:mm, in 24 hour clock), or in relative<br>
               dates such as 1d, 2w, 3m, 4y, which respectively mean one day,<br>
               two weeks, three months, or four years ago. 0d is last midnight,<br>
               and 0w, 0m, 0y is the beginning of this week, month, or year.'  }, { 'id' => 'chfieldvalue', 'html' => 'The value the field defined above changed to during that time.'  } ]);
    $output .=  "\n";
        } };
        if ($@) {
            $error = $context->catch($@, \$output);
            die $error unless $error->type eq 'return';
        }
    
        return $output;
    },
    DEFBLOCKS => {

    },
});
