page.title=Available Resource Types
@jd:body

<p>This page describes the different types of resources that you can
externalize from your code and package with your application. They fall into
the following groups:</p>
<ul>
    <li><a href="#simplevalues">Simple Values</a></li>
    <li><a href="#drawables">Drawables</a></li>
    <li><a href="#animation">Animation</a></li>
    <li><a href="#layoutresources">Layout</a></li>
    <li><a href="#stylesandthemes">Styles and Themes</a></li>
</ul>

<p>For more details on how to use resources in your application, please see the
    <a href="{@docRoot}devel/resources-i18n.html">Resources and i18n</a>
    documentation.</p>

<a name="simplevalues" id="simplevalues"></a>
<h2>Simple Values</h2>

<p>All simple resource values can be expressed as a string, using various
formats to unambiguously indicate the type of resource being created.  For
this reason, these values can be defined both as standard resources
(under res/values), as well as direct values supplied for
mappings in <a href="#stylesandthemes">styles and themes</a>, and attributes in
XML files such as <a href="#layoutresources">layouts</a>.</p>

<ul>
    <li><a href="#colorvals">Colors</a></li>
    <li><a href="#stringresources">Strings and Styled Text</a></li>
    <li><a href="#dimension">Dimensions</a></li>
</ul>


<a name="colorvals" id="colorvals"></a>
<h3>Color Values</h3>
<p>
    A color value specifies an RGB value with an alpha channel, which can
    be used in various places such as specifying a solid color for a Drawable
    or the color to use for text.  A color value always begins with
    a '#' character and then is followed by the alpha-red-green-blue information
    in one of the following formats:
</p>
<ul>
<li> #RGB
<li> #ARGB
<li> #RRGGBB
<li> #AARRGGBB
</ul>
<p>
    If you want to retrieve the color represented by a resource ID, you can call
    the {@link android.content.res.Resources#getColor(int) Resources.getColor()} method.
</p>
<p>
    <strong>Source file format:</strong> XML file requiring a
    <code>&lt;?xml version="1.0" encoding="utf-8"?&gt;</code> declaration, and
    a root <code>&lt;resources&gt;</code> element containing one or more
    <code>&lt;color&gt;</code> tags.
</p>
<p>
    <strong>Resource source file location</strong>: res/values/<em>colors</em>.xml (file name is arbitrary)
</p>
<p>
    <strong>Compiled resource datatype:</strong> Resource pointer to a Java int.
</p>
<p>
    <strong>Resource reference name:</strong>
</p>
<ul>
    <li>
        <strong>Java</strong> <code>R.color.<em>some_name</em></code>
    </li>
    <li>
        <strong>XML</strong> <code>@[<em>package</em>:]color/some_name</code> (where <em>some_name</em> is the <em>name</em> of a specific color)
    </li>
</ul>
<p>
    <strong>Syntax</strong>
</p>
<pre>
&lt;color name=<em>color_name</em>&gt;<em>#color_value</em>&lt;/color&gt;
</pre>
<dl>
    <dt>
        &lt;color&gt;
    </dt>
    <dd>
        Value is a color, using web-style syntax, as describe above. Has only one attribute:
        <ul>
            <li>
                <em>name</em> - The name used in referring to this color.
            </li>
        </ul>
    </dd>
</dl>
<p>
    <strong>Example XML Declaration</strong>
</p>
<p>
    The following code declares two colors, the first fully opaque, and the
    second translucent.
</p>
<pre>
&lt;resources&gt;
   &lt;color name="opaque_red"&gt;#f00&lt;/color&gt;
   &lt;color name="translucent_red"&gt;#80ff0000&lt;/color&gt;
&lt;/resources&gt;
</pre>
<p>
    <strong>Example Code Use</strong>
</p>
<p>
    Example Java code
</p>
<pre>
// Retrieve a color value.
int color = getResources.getColor(R.color.opaque_red);
</pre>
<p>
    Example XML code
</p>
<pre>
&lt;TextView android:layout_width="fill_parent"
          android:layout_height="wrap_content"
          android:textAlign="center"
          android:textColor="@color/translucent_red"
          android:text="Some Text"/&gt;
</pre>

<a name="stringresources" id="stringresources"></a>
<h3>Strings and Styled Text</h3>
<p>
    Strings, with optional <a href="#styledtext">simple formatting</a>, can be 
stored and retrieved as resources. You can add formatting to your string by 
using three standard HTML tags: &lt;b&gt;, &lt;i&gt;, and &lt;u&gt;. To 
guarantee getting an unstyled string only (the raw text) call the 
<code>toString()</code> method of the retrieved CharSequence object. 
Methods that accept string resources should be able to process these styling 
tags.
</p>
<p>
    If you want to retrieve the String represented by a resource ID, you can call the {@link android.content.Context#getString(int) Context.getString()} method.
</p>
<p>
    <strong>Note:</strong> If you use an apostrophe or a quote in your string, you must either escape it or enclose the whole string in the other kind of enclosing quotes:
</p>
<pre>
&lt;string name="good_example"&gt;"This'll work"&lt;/string&gt;
&lt;string name="good_example_2"&gt;This\'ll also work&lt;/string&gt;
&lt;string name="bad_example"&gt;This won't work!&lt;/string&gt;
&lt;string name="bad_example_2"&gt;XML encodings won&amp;apos;t work either!&lt;/string&gt;
</pre>
<p>
    <strong>Source file format:</strong> XML file requiring a <code>&lt;?xml version="1.0" encoding="utf-8"?&gt;</code> declaration, and a root <code>&lt;resources&gt;</code> element containing one or more <code>&lt;string&gt;</code> tags.
</p>
<p>
    <strong>Resource source file location</strong>: res/values/<em>strings</em>.xml (file name is arbitrary)
</p>
<p>
    <strong>Compiled resource datatype:</strong> Resource pointer to a Java CharSequence.
</p>
<p>
    <strong>Resource reference name:</strong>
</p>
<ul>
    <li>
        <strong>Java</strong> <code>R.string.<em>some_name</em></code>
    </li>
    <li>
        <strong>XML</strong> <code>@[<em>package</em>:]string/some_name</code> (where <em>some_name</em> is the <em>name</em> of a specific string)
    </li>
</ul>
<p>
    <strong>Syntax</strong>
</p>
<pre>
&lt;string name=<em>string_name</em>&gt;<em>string_value</em>&lt;/string&gt;
</pre>
<dl>
    <dt>
        &lt;string&gt;
    </dt>
    <dd>
        Value is a string, with optional styling tags. Has only one attribute:
        <ul>
            <li>
                <em>name</em> - The name used in referring to this string.
            </li>
        </ul>
    </dd>
</dl>
<p>
    <strong>Example XML Declaration</strong>
</p>
<p>
    The following declares two strings: the first &mdash; simple text with no
    formatting (resulting in a CharSequence that is simply a String object) &mdash; the second includes formatting information in the string (resulting
    in a CharSequence that is a complex data structure). If you are using the custom editor for string files in Eclipse, the HTML formatting tags will automatically be escaped and you will need to use {@link android.content.Context#getString(int) Context.getString()} and {@link android.text.Html#fromHtml} to retreive the resource and then convert it to formatted text.
</p>
<pre>
&lt;resources&gt;
   &lt;string name="simple_welcome_message"&gt;Welcome!&lt;/string&gt;
   &lt;string name="styled_welcome_message"&gt;We are &lt;b&gt;&lt;i&gt;so&lt;/i&gt;&lt;/b&gt; glad to see you.&lt;/string&gt;
&lt;/resources&gt;
</pre>
<p>
    <strong>Example Code Use</strong>
</p>
<p>
    Example Java code
</p>
<pre>
// Assign a styled string resource to a TextView
// on the current screen.
CharSequence str = getString(R.string.styled_welcome_message);
TextView tv = (TextView)findViewByID(R.id.text);
tv.setText(str);
</pre>
<p>
    Example XML code
</p>
<pre>
&lt;TextView android:layout_width="fill_parent"
          android:layout_height="wrap_content"
          android:textAlign="center"
          android:text="@string/simple_welcome_message"/&gt; 
</pre>

<a name="styledtext" id="styledtext"></a>
<h4>Using Styled Text as a Format String</h4>
<p>
Sometimes you may want to create a styled text resource that is also used as a 
format string. This cannot be done directly because there is no way of passing 
the styled text as the format string argument of String.format() 
without stripping out the style information. The workaround is to store the 
style tags as escaped HTML tags, and then convert the escaped HTML string into 
a styled text after formatting has taken place.
</p>
<p>
To use styled text as a format string, do the following.
</p>
<ol>
  <li>Store your styled text resource as an escaped string, so that the HTML tags in your text resource are not interpreted as if they were XML tags:
<pre>
&lt;resources&gt;
  &lt;string name="search_results_resultsTextFormat"&gt;%1$d results for &amp;lt;b>&amp;amp;quot;%2$s&amp;amp;quot;&amp;lt;/b>&lt;/string&gt;
&lt;/resources&gt;
</pre>
<p>
In this example the format string has two arguments: <code>%1$d</code> is a decimal number, <code>%2$s</code> is a string.
</p>
</li>
<li>
  Make sure any String arguments are properly escaped if they might contain '&lt;' or '&amp;' characters. 
The {@link android.text.TextUtils#htmlEncode} method will do this:
<pre>
String escapedTitle = TextUtil.htmlEncode(title);
</pre>
</li>
<li>
 Use String.format() to format the HTML text, then use {@link android.text.Html#fromHtml} to convert the HTML text into styled text:
<pre>
String resultsTextFormat = getContext().getResources().getString(R.string.search_results_resultsTextFormat);
String resultsText = String.format(resultsTextFormat, count, escapedTitle);
CharSequence styledResults = Html.fromHtml(resultsText);
</pre>
</li>
</ol>

<a name="dimension" id="dimension"></a>
<h3>Dimension Values</h3>
<p>You can create common dimensions to use for various screen elements by
defining dimension values in XML. A dimension resource is a number followed by
a unit of measurement. For example: 10px, 2in, 5sp. Here are the units of
measurement supported by Android:</p>
<dl>
    <dt>px</dt>
    <dd>Pixels - corresponds to actual pixels on the screen.</dd>

    <dt>in</dt>
    <dd>Inches - based on the physical size of the screen.</dd>

    <dt>mm</dt>
    <dd>Millimeters - based on the physical size of the screen.</dd>

    <dt>pt</dt>
    <dd>Points - 1/72 of an inch based on the physical size of the screen.</dd>

    <dt>dp</dt>
    <dd>Density-independent Pixels - an abstract unit that is based on the
    physical density of the screen. These units are relative to a 160 dpi
    screen, so one dp is one pixel on a 160 dpi screen. The ratio of
    dp-to-pixel will change with the screen density, but not necessarily
    in direct proportion. <strong>Note:</strong> The compiler accepts both "dip" and "dp", though "dp" is more consistent with "sp".</dd>

    <dt>sp</dt>
    <dd>Scale-independent Pixels - this is like the dp unit, but it is also
    scaled by the user's font size preference. It is recommend you use this
    unit when specifying font sizes, so they will be adjusted for both the
    screen density and user's preference.</dd>
</dl>

<p>Dimension values are not normally used as raw resources, but rather as
attribute values in XML files. You can, however, create plain resources
containing this data type.</p>

<p><strong>Source file format:</strong> XML file requiring a <code>&lt;?xml
version="1.0" encoding="utf-8"?&gt;</code> declaration, and a root
<code>&lt;resources&gt;</code> element containing one or more
<code>&lt;dimen&gt;</code> tags.</p>

<p><strong>Resource source file location</strong>: res/values/dimens.xml (File
name is arbitrary; standard practice is to put all dimensions in one file
devoted to dimensions.)</p>
<p><strong>Compiled resource datatype:</strong> Resource pointer to a
dimension.</p>
<p>
    <strong>Resource reference name:</strong>
</p>
<ul>
    <li>
        <strong>Java</strong> <code>R.dimen.<em>some_name</em></code>
    </li>
    <li>
        <strong>XML</strong> <code>@[<em>package</em>:]dimen/<em>some_name</em></code> (where <em>some_name</em> is the <em>name</em> of a specific <code>&lt;dimen&gt;</code> element)
    </li>
</ul>
<p>
    <strong>Syntax</strong>
</p>
<pre>
&lt;dimen name=<em>dimen_name</em>&gt;<em>dimen_value</em>&lt;/dimen&gt;
</pre>
<dl>
    <dt>
        &lt;dimen&gt;
    </dt>
    <dd>
        A valid dimension value.
        <ul>
            <li>
                <em>name</em> - The name used in referring to this dimension.
            </li>
        </ul>
    </dd>
</dl>
<p>
    <strong>Example XML Declaration</strong>
</p>
<p>
    The following code declares several dimension values.
</p>
<pre>
&lt;resources&gt;
    &lt;dimen name="one_pixel"&gt;1px&lt;/dimen&gt;
    &lt;dimen name="double_density"&gt;2dp&lt;/dimen&gt;
    &lt;dimen name="sixteen_sp"&gt;16sp&lt;/dimen&gt;
&lt;/resources&gt;
</pre>
<p>
    <strong>Example Code Use</strong>
</p>
<p>
    Example Java code:
</p>
<pre>
float dimen = Resources.getDimen(R.dimen.one_pixel);
</pre>
<p>
    Example XML code:
</p>
<pre>
&lt;TextView android:layout_width="fill_parent"
          android:layout_height="wrap_content"
          android:textSize="@dimen/sixteen_sp"/&gt;
</pre>

<a name="drawables" id="drawables"></a>
<h2>Drawables</h2>

<p>A {@link android.graphics.drawable.Drawable} is a type of resource that
you retrieve with {@link android.content.res.Resources#getDrawable
Resources.getDrawable()} and use to draw to the screen.  There are a
number of drawable resources that can be created.</p>

<ul>
    <li><a href="#imagefileresources">Bitmap Drawables</a></li>
    <li><a href="#colordrawableresources">Color Drawables</a></li>
    <li><a href="#ninepatch">Nine Patch (Stretchable) Drawables</a></li>
</ul>

<a name="imagefileresources" id="imagefileresources"></a>
<h3>Bitmap files</h3>
<p>Android supports bitmap resource files in a few different formats: png
(preferred), jpg (acceptable), gif (discouraged). The bitmap file itself is
compiled and referenced by the file name without the extension (so
res/drawable/my_picture.png would be referenced as R.drawable.my_picture).</p>

<p>
    <strong>Source file formats:</strong> png (preferred), jpg (acceptable), gif (discouraged). One resource per file.
</p>
<p>
    <strong>Resource file location</strong>: res/drawable/<em>some_file</em>.png or <em>some_file</em>.jpg or <em>some_file</em>.gif.
</p>
<p>
    <strong>Compiled resource datatype:</strong> Resource pointer to a {@link android.graphics.drawable.BitmapDrawable BitmapDrawable}.
</p>
<p>
    <strong>Resource reference name:</strong>
</p>
<ul>
    <li>
        <strong>Java</strong> <code>R.drawable.<em>some_file</em></code>
    </li>
    <li>
        <strong>XML</strong> <code>@[<em>package</em>:]drawable/<em>some_file</em></code>
    </li>
</ul>
<p>
    <strong>Example Code Use</strong>
</p>
<p>
    The following Java snippet demonstrates loading an {@link android.widget.ImageView ImageView} object with a single bitmap from a list of bitmap resources. ImageView is a basic display rectangle for graphics (animations or still images).
</p>
<pre>
// Load an array with BitmapDrawable resources.
private Integer[] mThumbIds = {
   R.drawable.sample_thumb_0,
   R.drawable.sample_thumb_1,
   R.drawable.sample_thumb_2,
   R.drawable.sample_thumb_3,
   R.drawable.sample_thumb_4
};

// Load and return a view with an image.
public View getView(int position, ViewGroup parent)
{
   ImageView i = new ImageView(mContext);
   i.setImageResource(mThumbIds[position]);
   i.setAdjustViewBounds(true);
   i.setLayoutParams(new Gallery.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT));
   i.setBackground(android.R.drawable.picture_frame);
   return i;
}
</pre>
<p>
    This XML example demonstrates loading a bitmap file (chat_icon.png) in an ImageView.
</p>
<pre>
&lt;ImageView id="@+id/icon"
   android:layout_width="wrap_content"
   android:layout_height="wrap_content"
   android:tint="#FF000000"
   android:src="@drawable/chat_icon"/&gt;
</pre>

<a name="colordrawableresources" id="colordrawableresources"></a>
<h3>Color Drawables</h3>
<p>You can create a {@link android.graphics.drawable.PaintDrawable} object that is a rectangle of color,
with optionally rounded corners. This element can be defined in any of the
files inside res/values/.</p>
<p><strong>Source file format:</strong> XML file requiring a <code>&lt;?xml
version="1.0" encoding="utf-8"?&gt;</code> declaration, and a root
<code>&lt;resources&gt;</code> element containing one or more
<code>&lt;drawable&gt;</code> tags.</p>
<p>
    <strong>Resource source file location</strong>: res/values/colors.xml (File name is arbitrary; standard practice is to put the PaintDrawable items in the file along with the <a href="{@docRoot}devel/resources-i18n.html#numericcolorresources">numeric color values</a>.)
</p>
<p>
    <strong>Compiled resource datatype:</strong> Resource pointer to a {@link android.graphics.drawable.PaintDrawable}.
</p>
<p>
    <strong>Resource reference name:</strong>
</p>
<ul>
    <li>
        <strong>Java</strong>  <code>R.drawable.<em>some_name</em></code>
    </li>
    <li>
        <strong>XML</strong>  <code>@[<em>package</em>:]drawable/<em>some_name</em></code>  (where <em>some_name</em> is the name of a specific resource)
    </li>
</ul>
<p>
    <strong>Syntax</strong>
</p>
<pre>
&lt;drawable name=<em>color_name</em>&gt;<em>color_value</em>&lt;/drawable&gt;
</pre>
<dl>
    <dt>
        &lt;drawable&gt;
    </dt>
    <dd>
        A valid <a href="#colorvals">color value</a>.
        <ul>
            <li>
                <em>name</em> - The name used in referring to this drawable.
            </li>
        </ul>
    </dd>
</dl>
<p>
    <strong>Example XML Declaration</strong>
</p>
<p>
    The following code declares several color drawables.
</p>
<pre>
&lt;resources&gt;
    &lt;drawable name="solid_red"&gt;#f00&lt;/drawable&gt;
    &lt;drawable name="solid_blue"&gt;#0000ff&lt;/drawable&gt;
    &lt;drawable name="solid_green"&gt;#f0f0&lt;/drawable&gt;
&lt;/resources&gt;
</pre>
<p>
    <strong>Example Code Use</strong>
</p>
<p>
    Example Java code
</p>
<pre>
// Assign a PaintDrawable as the background to
// a TextView on the current screen.
Drawable redDrawable = Resources.getDrawable(R.drawable.solid_red);
TextView tv = (TextView)findViewByID(R.id.text);
tv.setBackground(redDrawable);
</pre>
<p>
    Example XML code
</p>
<pre>
&lt;TextView android:layout_width="fill_parent"
          android:layout_height="wrap_content"
          android:textAlign="center"
          android:background="@drawable/solid_red"/&gt;
</pre>

<a name="ninepatch" id="ninepatch"></a>
<h3>Nine-Patch Stretchable Image</h3>
<p>
    Android supports a stretchable bitmap image, called a 
    {@link android.graphics.NinePatch} graphic. This is a PNG image in which 
    you define stretchable sections that Android will resize to fit the object 
    at display time to accommodate variable sized sections, such as text strings. 
    You typically assign this resource to the View's background. An example use 
    of a stretchable image is the button backgrounds that Android uses; buttons 
    must stretch to accommodate strings of various lengths.
</p>
<p>
    A NinePatch drawing is a standard PNG image that includes a 1 pixel wide 
    border. This border is used to define the stretchable and static areas of 
    the screen. You indicate a stretchable section by drawing one or more 1 pixel 
    wide black lines in the left or top part of this border. You can have as 
    many stretchable sections as you want. The relative size of the stretchable 
    sections stays the same, so the largest sections always remain the largest.
</p>
<p>
    You can also define an optional drawable section of the image (effectively, 
    the padding lines) by drawing a line on the right and bottom lines. If you 
    do not draw these lines, the first top and left lines will be used.
</p>
<p>
    If a View object sets this graphic as a background and then specifies the 
    View object's text, it will stretch itself so that all the text fits inside 
    the area designated by the right and bottom lines (if included). If the 
    padding lines are not included, Android uses the left and top lines to 
    define the writeable area.
</p>
<p>The <a href="{@docRoot}reference/draw9patch.html">Draw 9-patch</a> tool offers 
   an extremely handy way to create your NinePatch images, using a 
   WYSIWYG graphics editor.
</p>
<p>
    Here is a sample NinePatch file used to define a button.
</p>
<p>
    <img src="{@docRoot}images/ninepatch_raw.png" alt="Raw ninepatch file 
    showing the definition lines">
</p>
<p>
    This ninepatch uses one single stretchable area, and it also defines a drawable area.
</p>
<p>
    <strong>Source file format:</strong> PNG &mdash; one resource per file
</p>
<p>
    <strong>Resource source file location</strong>: res/drawable/<em>some_name</em>.9.png (must end in .9.png)
</p>
<p>
    <strong>Compiled resource datatype:</strong> Resource pointer to a {@link android.graphics.drawable.NinePatchDrawable NinePatchDrawable}.
</p>
<p>
    <strong>Resource reference name:</strong>
</p>
<ul>
    <li>
        <strong>Java</strong> <code>R.drawable.<em>some_file</em></code>
    </li>
    <li>
        <strong>XML</strong> <code>@[<em>package</em>:]drawable.<em>some_file</em></code>
    </li>
</ul>
<p>
    <strong>Example XML Code</strong>
</p>
<p>
    Note that the width and height are set to "wrap_content" to make the button fit neatly around the text.
</p>
<pre>
&lt;Button id="@+id/tiny"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentTop="true"
        android:layout_centerInParent="true"
        android:text="Tiny"
        android:textSize="8sp"
        android:background="@drawable/my_button_background"/&gt;

&lt;Button id="@+id/big"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:layout_centerInParent="true"
        android:text="Biiiiiiig text!"
        android:textSize="30sp"
        android:background="@drawable/my_button_background"/&gt;
</pre>
<p>
    Here are the two buttons based on this XML and the NinePatch graphic shown above. Notice how the width and height of the button varies with the text, and the background image stretches to accommodate it.
</p>
<p>
    <img src="{@docRoot}images/ninepatch_examples.png" alt="Two buttons based on the NinePatch button background">
</p>

<a name="animation" id="animation"></a>
<h2>Animation</h2>
<a name="tweenedanimation" id="tweenedanimation"></a>
<h3>
    Tweened Animation
</h3>
<p>
    Android can perform simple animation on a graphic, or a series of graphics. These include rotations, fading, moving, and stretching.
</p>
<p>
    <strong>Source file format:</strong> XML file, one resource per file, one root tag with no <code>&lt;?xml&gt;</code> declaration
</p>
<p>
    <strong>Resource file location</strong>: res/anim/<em>some_file</em>.xml
</p>
<p>
    <strong>Compiled resource datatype:</strong> Resource pointer to an {@link android.view.animation.Animation}.
</p>
<p>
    <strong>Resource reference name:</strong>
</p>
<ul>
    <li>
        <strong>Java</strong> <code>R.anim.<em>some_file</em></code>
    </li>
    <li>
        <strong>XML</strong> <code>@[<em>package</em>:]anim/<em>some_file</em></code>
    </li>
</ul>
<p>
    <strong>Syntax</strong>
</p>
<p>
    The file must have a single root element: this will be either a single <code>&lt;alpha&gt;</code>, <code>&lt;scale&gt;</code>, <code>&lt;translate&gt;</code>, <code>&lt;rotate&gt;</code>, interpolator element, or <code>&lt;set&gt;</code> element that holds groups of these elements (which may include another <code>&lt;set&gt;</code>). By default, all elements are applied simultaneously. To have them occur sequentially, you must specify the <code>startOffset</code> attribute, as shown in the example code.
</p>
<pre>
&lt;set android:shareInterpolator=boolean&gt;  // Only required if multiple tags are used.
   &lt;alpha android:fromAlpha=float
          android:toAlpha=float &gt;   |
   &lt;scale android:fromXScale=float
          android:toXScale=float
          android:fromYScale=float
          android:toYScale=float
          android:pivotX=string
          android:pivotY=string&gt;    |
   &lt;translate android:fromX=string
              android:toX=string
              android:fromY=string
              android:toY=string&gt;   |
   &lt;rotate android:fromDegrees=float
           android:toDegrees=float
           android:pivotX=string
           android:pivotY=string /&gt; |
   &lt;<em>interpolator tag</em>&gt;
   &lt;set&gt;
&lt;/set&gt;
</pre>
<p>
    <strong>Elements and Attributes</strong>
</p>
<dl>
    <dt>
        &lt;set&gt;
    </dt>
    <dd>
        The outermost tag, which can recursively hold itself or other animations. You can include as many child elements of the same or different types as you like. Supports the following attribute:
        <ul>
            <li>
                <em>shareInterpolator</em> - Whether to share the same Interpolator among all immediate child elements.
            </li>
        </ul>
    </dd>
    <dt>
        &lt;alpha&gt;
    </dt>
    <dd>
        A fading animation, compiled to {@link android.view.animation.AlphaAnimation}. Supports the following attributes:
        <ul>
            <li>
                <em>fromAlpha</em> - 0.0 to 1.0, where 0.0 is transparent.
            </li>
            <li>
                <em>toAlpha</em> - 0.0 to 1.0, where 0.0 is transparent.
            </li>
        </ul>
    </dd>
    <dt>
        &lt;scale&gt;
    </dt>
    <dd>
        A resizing animation, compiled to {@link android.view.animation.ScaleAnimation}. You can specify what is the center point of the image (the pinned center), from which it grows outward (or inward), by specifying pivotX and pivotY. So, for example, if these were 0, 0 (top left corner), all growth would be down and to the right. <code>scale</code> supports the following attributes:
        <ul>
            <li>
                <em>fromXScale</em> - Starting X size, where 1.0 is no change.
            </li>
            <li>
                <em>toXScale</em> - Ending X size, where 1.0 is no change.
            </li>
            <li>
                <em>fromYScale</em> - Starting Y size, where 1.0 is no change.
            </li>
            <li>
                <em>toYScale</em> - Ending Y size, where 1.0 is no change.
            </li>
            <li>
                <em>pivotX</em> - The X coordinate of the pinned center.
            </li>
            <li>
                <em>pivotY</em> - The Y coordinate of the pinned center.
            </li>
        </ul>
    </dd>
    <dt>
        &lt;translate&gt;
    </dt>
    <dd>
        A motion animation that moves a visual element within its parent element. It is equivalent to {@link android.view.animation.TranslateAnimation}. 
Supports the following attributes in any of the following three formats: values from -100 to 100, ending with "%", indicating a percentage relative to itself; values from -100 to 100, ending in "%p", indicating a percentage relative to its parent; a float with no suffix, indicating an absolute value.
        <ul>
            <li>
                <em>fromXDelta</em> - Starting X location.
            </li>
            <li>
                <em>toXDelta</em> - Ending X location.
            </li>
            <li>
                <em>fromYDelta</em> - Starting Y location.
            </li>
            <li>
                <em>toYDelta</em> - Ending Y location.
            </li>
        </ul>
    </dd>
    <dt>
        &lt;rotate&gt;
    </dt>
    <dd>
        A rotation animation, compiled to {@link android.view.animation.RotateAnimation}. Supports the following attributes:
        <ul>
            <li>
                <em>fromDegrees</em> - Starting rotation, in degrees.
            </li>
            <li>
                <em>toDegrees</em> - Ending rotation, in degrees.
            </li>
            <li>
                <em>pivotX</em> - The X coordinate of the center of rotation, in pixels, where (0,0) is the top left corner.
            </li>
            <li>
                <em>pivotY</em> - The Y coordinate of the center of rotation, in pixels, where (0,0) is the top left corner.
            </li>
        </ul>
    </dd>
    <dt>
        <em>&lt;interpolator tag&gt;</em>
    </dt>
    <dd>
        You can also use any of the interpolator subclass elements defined in {@link android.R.styleable}. Examples include &lt;CycleInterpolator&gt;, &lt;EaseInInterpolator&gt;, and &lt;EaseOutInterpolator&gt;. These objects define a velocity curve that describes how quickly a visual action takes place on a timeline (fast at first and slow later, slow at first and gradually faster, and so on).
    </dd>
</dl>
<p>
    Note that alpha, scale, rotate, translate all support the following attributes from the base animation class, BaseAnimation:
</p>
<dl>
    <dt>
        <em>duration</em>
    </dt>
    <dd>
        Duration, in milliseconds, for this effect.
    </dd>
    <dt>
        <em>startOffset</em>
    </dt>
    <dd>
        Offset start time for this effect, in milliseconds.
    </dd>
    <dt>
        <em>fillBefore</em>
    </dt>
    <dd>
        Equivalent to {@link android.view.animation.Animation#setFillBefore animation.Animation.setFillBefore()}.
    </dd>
    <dt>
        <em>fillAfter</em>
    </dt>
    <dd>
        Equivalent to {@link android.view.animation.Animation#setFillAfter animation.Animation.setFillAfter()}.
    </dd>
    <dt>
        <em>interpolator</em>
    </dt>
    <dd>
        You can optionally set an interpolator for each element to determine how quickly or slowly it performs its effect over time. For example, slow at the beginning and faster at the end for EaseInInterpolator, and the reverse for EaseOutInterpolator. A list of interpolators is given in {@link android.R.anim}. To specify these, use the syntax @android:anim/<em>interpolatorName</em>.
    </dd>
</dl>
<p>
    <strong>Example XML Declaration</strong>
</p>
<p>
    The following XML from the ApiDemos application is used to stretch, then simultaneously spin and rotate a block of text.
</p>
<pre>
&lt;set android:shareInterpolator="false"&gt;
   &lt;scale
          android:interpolator="&#64;android:anim/ease_in_out_interpolator"
          android:fromXScale="1.0"
          android:toXScale="1.4"
          android:fromYScale="1.0"
          android:toYScale="0.6"
          android:pivotX="50%"
          android:pivotY="50%"
          android:fillAfter="false"
          android:duration="700" /&gt;
   &lt;set android:interpolator="&#64;android:anim/ease_in_interpolator"&gt;
      &lt;scale
             android:fromXScale="1.4" 
             android:toXScale="0.0"
             android:fromYScale="0.6"
             android:toYScale="0.0" 
             android:pivotX="50%" 
             android:pivotY="50%" 
             android:startOffset="700"
             android:duration="400" 
             android:fillBefore="false" /&gt;
      &lt;rotate 
             android:fromDegrees="0" 
             android:toDegrees="-45"
             android:toYScale="0.0" 
             android:pivotX="50%" 
             android:pivotY="50%"
             android:startOffset="700"
             android:duration="400" /&gt;
   &lt;/set&gt;
&lt;/set&gt;
</pre>
<p>
    The following Java code loads animations called res/anim/hyperspace_in.xml and res/anim/hyperspace_out.xml into a {@link android.widget.ViewFlipper}.
</p>
<pre>
mFlipper.setInAnimation(AnimationUtils.loadAnimation(this, R.anim.hyperspace_in));
mFlipper.setOutAnimation(AnimationUtils.loadAnimation(this, R.anim.hyperspace_out)); 
</pre>

<a name="layoutresources" id="layoutresources"></a>
<h2>Layout</h2>
<p>
    Android lets you specify screen layouts using XML elements inside an XML file, similar to designing screen layout for a webpage in an HTML file. Each file contains a whole screen or a part of a screen, and is compiled into a View resource that can be passed in to {@link android.app.Activity#setContentView(int) Activity.setContentView} or used as a reference by other layout resource elements. Files are saved in the res/layout/ folder of your project, and compiled by the Android resource compiler aapt.
</p>
<p>
    Every layout XML file must evaluate to a single root element. First we'll describe how to use the standard XML tags understood by Android as it is shipped, and then we'll give a little information on how you can define your own custom XML elements for custom View objects. See <a href="{@docRoot}devel/implementing-ui.html">Implementing a User Interface</a> for details about the visual elements that make up a screen.
</p>
<p>
    The root element must have the Android namespace "http://schemas.android.com/apk/res/android" defined in the root element
</p>
<p>
    <strong>Source file format:</strong> XML file requiring a <code>&lt;?xml version="1.0" encoding="utf-8"?&gt;</code> declaration, and a root element of one of the supported XML layout elements.
</p>
<p>
    <strong>Resource file location</strong>: res/layout/<em>some_file</em>.xml.
</p>
<p>
    <strong>Compiled resource datatype:</strong> Resource pointer to a {@link android.view.View} (or subclass) resource.
</p>
<p>
    <strong>Resource reference name:</strong>
</p>
<ul>
    <li>
        <strong>Java</strong> <code>R.drawable.<em>some_file</em></code>
    </li>
    <li>
        <strong>XML</strong> <code>@[<em>package</em>:]layout/<em>some_file</em></code>
    </li>
</ul>
<p>
    <strong>Syntax</strong>
</p>
<pre>
&lt;<em>ViewGroupClass</em> xmlns:android="http://schemas.android.com/apk/res/android"
                id="@+id/<em>string_name</em>" (attributes)&gt;
   &lt;<em>widget</em> or other nested <em>ViewGroupClass</em>&gt;+
   &lt;requestFocus/&gt;(0 or 1 per layout file, assigned to any element)
&lt;/<em>ViewGroupClass</em>&gt;
</pre>
<dl>
    <dt>
        &lt;<em>ViewGroupClass</em>&gt;
    </dt>
    <dd>
        <p>The file must have a single root element. This can be a ViewGroup class that contains other elements, or a widget (or custom item) if it's only one object. By default, you can use any (case-sensitive) Android {@link android.widget widget} or {@link android.view.ViewGroup ViewGroup} class name as an element. These elements support attributes that apply to the underlying class, but the naming is not as clear. How to discover what attributes are supported for what tags is discussed below. You should not assume that any nesting is valid (for example you cannot enclose <code>&lt;TextView&gt;</code> elements inside a <code>&lt;ListLayout&gt;</code>).</p>
        <p>If a class derives from another class, the XML element inherits all the attributes from the element that it "derives" from. So, for example, <code>&lt;EditText&gt;</code> is the corresponding XML element for the EditText class. It exposes its own unique attributes (<code>EditText_numeric</code>), as well as all attributes supported by <code>&lt;TextView&gt;</code> and <code>&lt;View&gt;</code>. For the <em>id</em> attribute of a tag in XML, you should use a special syntax: "@+id/<em>somestringvalue</em>". The "@+" syntax creates a resource number in the R.id class, if one doesn't exist, or uses it, if it does exist. When declaring an ID value for an XML tag, use this syntax. Example: <code>&lt;TextView id="@+id/nameTextbox"/&gt;</code>, and refer to it this way in Java: <code>findViewById(R.id.nameTextbox)</code>. All elements support the following values:</p>
        <ul>
            <li>
                <em>id</em> - An ID value used to access this element in Java. Typically you will use the syntax @+id/<em>string_name</em> to generate an ID for you in the id.xml file if you haven't created one yourself.
            </li>
            <li>
                <code>xmlns:android="http://schemas.android.com/apk/res/android"</code> - <em><strong>Required for the root element only.</strong></em>
            </li>
        </ul>
    </dd>
    <dt>
        &lt;requestFocus&gt;
    </dt>
    <dd>
        Any element representing a View object can include this empty element, which gives it's parent tag initial focus on the screen. You can have only one of these elements per file.
    </dd>
</dl>
<p>
    <strong>What Attributes Are Supported for What Elements?</strong>
</p>
<p>
    Android uses the {@link android.view.LayoutInflater} class at run time to load an XML layout resource and translate it into visual elements. By default, all widget class names are supported directly as tags, but a full list of supported tags and attributes is listed in the {@link android.R.styleable} reference page. However, the attribute names are somewhat obscure. If an underscore appears in the name, this indicates that it is an attribute &mdash; typically of the element before the underscore. So, for example, <code>EditText_autoText</code> means that the <code>&lt;EditText&gt;</code> tag supports an attribute <em>autoText</em>. When you actually use the attribute in that element, use only the portion after the last underscore, and prefix the attribute with the prefix "<code>android:</code>". So, for example, if {@link android.R.styleable} lists the following values:
</p>
<ul>
    <li>
        <code>TextView</code>
    </li>
    <li>
        <code>TextView_lines</code>
    </li>
    <li>
        <code>TextView_maxlines</code>
    </li>
</ul>
<p>
    You could create an element like this:
</p>
<pre>
&lt;TextView android:lines="10" android:maxlines="20"/&gt;
</pre>
<p>
    This would create a {@link android.widget.TextView} object and set its lines and maxlines properties.
</p>
<p>
    Attributes come from three sources:
</p>
<ul>
    <li>
        <strong>Attributes exposed directly by the element.</strong> For example, <code>TextView</code> supports <code>TextView_text</code>, as discussed above.
    </li>
    <li>
        <strong>Attributes exposed by all the superclasses of that element.</strong> For example, the TextView class extends the View class, so the <code>&lt;TextView&gt;</code> element supports all the attributes that the <code>&lt;View&gt;</code> element exposes &mdash; a long list, including <code>View_paddingBottom</code> and <code>View_scrollbars</code>. These too are used without the class name: <code>&lt;TextView android:paddingBottom="20" android:scrollbars="horizontal" /&gt;</code>.
    </li>
    <li>
        <strong>Attributes of the object's {@link android.view.ViewGroup.LayoutParams} subclass.</strong> All View objects support a LayoutParams member (see <a href="{@docRoot}devel/ui/layout.html">LayoutParams in Implementing a UI</a>). To set properties on an element's LayoutParams member, the attribute to use is "android:layout_<em>layoutParamsProperty</em>". For example: <code>android:layout_gravity</code> for an object wrapped by a <code>&lt;LinearLayout&gt;</code> element. Remember that each LayoutParams subclass also supports inherited attributes. Attributes exposed by each subclass are given in the format <em>someLayoutParamsSubclass</em>_Layout_layout_<em>someproperty</em>. This defines an attribute "android:layout_<em>someproperty</em>". Here is an example of how Android documentation lists the properties of the {@link android.widget.LinearLayout.LayoutParams LinearLayout.LayoutParams} class:
    </li>
</ul>
<ul>
    <li>LinearLayout_Layout // The actual object &mdash; not used.
    </li>
    <li>LinearLayout_Layout_layout_gravity // Exposes a <code>gravity</code> attribute
    </li>
    <li>LinearLayout_Layout_layout_height // Exposes a <code>height</code> attribute
    </li>
    <li>LinearLayout_Layout_layout_weight // Exposes a <code>weight</code> attribute
    </li>
    <li>LinearLayout_Layout_layout_width // Exposes a <code>width</code> attribute
    </li>
</ul>
<p>
    Here is an example that sets some of these values on a few objects, including direct attributes, inherited attributes, and LayoutParams attributes:
</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!-- res/main_screen.xml --&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:orientation="vertical"    // The object's own orientation property
              android:padding="4"               // Inherited View property
              android:gravity="center"          // The object's own property
              android:layout_width="fill_parent"  // Parent object's LinearLayout.LayoutParams.width
              android:layout_height="fill_parent"&gt; // Parent object's LinearLayout.LayoutParams.height

   &lt;TextView android:layout_width="fill_parent"   // TextView.LayoutParams.width
             android:layout_height="wrap_content" // TextView.LayoutParams.height
             android:layout_weight="0"            // TextView.LayoutParams.weight
             android:paddingBottom="4"            // TextView.paddingBottom
             android:text="@string/redirect_getter"/&gt; // TextView.text

   &lt;EditText id="@+id/text"
             android:layout_width="fill_parent"   // EditText.LayoutParams.width
             android:layout_height="wrap_content" // EditText.LayoutParams.height
             android:layout_weight="0"            // EditText.LinearLayoutParams.weight
             android:paddingBottom="4"&gt;           // EditText.paddingBottom
       &lt;requestFocus /&gt;
   &lt;/EditText&gt;

   &lt;Button id="@+id/apply"
           android:layout_width="wrap_content"  // Button.LayoutParams.width
           android:layout_height="wrap_content" // Button.LayoutParams.height
           android:text="@string/apply" /&gt;      // TextView.text
&lt;/LinearLayout&gt;
</pre>
<p>
    <strong>Example Code Use</strong>
</p>
<p>
    The most common use is to load the XML file (located at <em>res/main_screen.xml</em>) and use it as the current screen, as shown here with the preceding file:
</p>
<pre>
setContentView(R.layout.main_screen); 
</pre>
<p>
    However, layout elements can also represent repeating elements used as templates.
</p>
<a name="customresources" id="customresources"></a>
<h3>Custom Layout Resources</h3>
<p>
    You can define custom elements to use in layout resources. These custom elements can then be used the same as any Android layout elements: that is, you can use them and specify their attributes in other resources. The ApiDemos sample application has an example of creating a custom layout XML tag, LabelView. To create a custom element, you will need the following files:
</p>
<ul>
    <li>
        <strong>Java implementation file</strong> - The implementation file. The class must extend {@link android.view.View View} or a subclass. See LabelView.java in ApiDemos.
    </li>
    <li>
        <strong>res/values/attrs.xml</strong> - Defines the XML element, and the attributes that it supports, for clients to use to instantiate your object in their layout XML file. Define your element in a <code>&lt;declare-styleable id=<em>your_java_class_name</em>&gt;</code>. See res/layout/attrs.xml in ApiDemos.
    </li>
    <li>
        <strong>res/layout/<em>your_class</em>.xml</strong> [<em>optional</em>] - An optional XML file to describe the layout of your object. This could also be done in Java. See custom_view_1.xml in ApiDemos.
    </li>
</ul>
<p>
    <strong>Source file format:</strong> XML file without an <code>&lt;?xml&gt;</code> declaration, and a <code>&lt;resources&gt;</code> root element containing one or more custom element tags.
</p>
<p>
    <strong>Resource file location</strong>: res/values/<em>attrs</em>.xml (file name is arbitrary).
</p>
<p>
    <strong>Compiled resource datatype:</strong> Resource pointer to a {@link android.view.View} (or subclass) resource.
</p>
<p>
    <strong>Resource reference name:</strong> R.styleable.<em>some_file</em> (Java).
</p>

<a name="stylesandthemes" id="stylesandthemes"></a>
<h2>Styles and Themes</h2>
<p>
    A <em>style</em> is one or more attributes applied to a single element (for example, 10 point red Arial font, applied to a TextView). A style is applied as an attribute to an element in a layout XML file.
</p>
<p>
    A <em>theme</em> is one or more attributes applied to a whole screen &mdash; for example, you might apply the stock Android Theme.dialog theme to an activity designed to be a floating dialog box. A theme is assigned as an attribute to an Activity in the manifest file.
</p>
<p>
    Both styles and themes are defined in a &lt;style&gt; block containing one or more string or numerical values (typically color values), or references to other resources (drawables and so on). These elements support inheritance, so you could have MyBaseTheme, MyBaseTheme.Fancy, MyBaseTheme.Small, and so on.
</p>
<p>
    <strong>Source file format:</strong> XML file requiring a <code>&lt;?xml version="1.0" encoding="utf-8"?&gt;</code> declaration, and a root <code>&lt;resources&gt;</code> element containing one or more <code>&lt;style&gt;</code> tags.
</p>
<p>
    <strong>Resource source file location</strong>: res/values/styles.xml (file name is arbitrary). The file name is arbitrary, but standard practice is to put all styles into a file named styles.xml.
</p>
<p>
    <strong>Compiled resource datatype:</strong> Resource pointer to a Java CharSequence.
</p>
<p>
    <strong>Resource reference name:</strong>
</p>
<ul>
    <li>
        <strong>Java</strong> <code>R.style.<em>styleID</em></code> for the whole style, <code>R.style.<em>styleID</em>.<em>itemID</em></code> for an individual setting
    </li>
    <li>
        <strong>XML</strong> <code>@[<em>package</em>:]style/<em>styleID</em></code> for a whole style, <code>@[<em>package</em>:]style/<em>styleID</em>/<em>itemID</em></code> for an individual item. <strong>Note</strong>: to refer to a value in the <em>currently</em> applied theme, use "?" instead of "@" as described below (XML).
    </li>
</ul>
<p>
    <strong>Syntax</strong>
</p>
<pre>
&lt;style name=<em>string</em> [parent=<em>string</em>] &gt;
   &lt;item name=<em>string</em>&gt;<em>Hex value | string value | reference</em>&lt;/item&gt;+<em>
</em>&lt;/style&gt;
</pre>
<dl>
    <dt>
        &lt;style&gt;
    </dt>
    <dd>
        Holds one or more &lt;item&gt; elements, each describing one value. This style, which is a bundle of values, can be referred to as a <em>theme</em>.
        <ul>
            <li>
                <em>name</em> - The name used in referring to this theme.
            </li>
            <li>
                <em>parent</em> - An optional parent theme. All values from the specified theme will be inherited into this theme. Any values with identical names that you specify will override inherited values. The name must be qualified by the package, but you don't need the /style directive (for example, <code>android:Theme</code> for the base Android theme, or <code>MyTheme</code> for a theme defined in your package).
            </li>
        </ul>
    </dd>
    <dt>
        &lt;item&gt;
    </dt>
    <dd>
        A value to use in this theme. It can be a standard string, a hex color value, or a reference to any other resource type.
    </dd>
</dl>
<p>
    <strong>Example: Declaring a Style in XML</strong>
</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;
    &lt;style name="SpecialText"&gt;
        &lt;item name="android:textSize"&gt;18sp&lt;/item&gt;
        &lt;item name="android:textColor"&gt;#008&lt;/item&gt;
    &lt;/style&gt;
&lt;/resources&gt;
</pre>
<p>
    <strong>Example: Referencing a Declared Style from an XML Resource</strong>
</p>
<p>
    The following layout XML file applies the previously defined style to a single text box.
</p>
<pre>
&lt;!-- MainPageLayout.xml --&gt;
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_height="fill_parent"
              android:layout_width="fill_parent"
              android:orientation="vertical"
              android:scrollbars="vertical"
              id="main_frame"&gt;
    &lt;EditText id="@+id/text1"
              style="@style/SpecialText"
              android:layout_width="fill_parent"
              android:layout_height="wrap_content"
              android:text="Hello, World!" /&gt;
&lt;/LinearLayout&gt;
</pre>


<p>
    <strong>Example XML Declaration of a Theme</strong>
</p>
<p>
    The following example defines a theme, "ThemeNew," which creates new theme items, 
    refers to some previously defined theme items (values beginning with '@'), 
    and refers to package resources (values beginning with '?').
</p>
<pre>
&lt;style name="ThemeNew"&gt;
   &lt;item name="windowFrame"&gt;@drawable/screen_frame&lt;/item&gt;
   &lt;item name="windowBackground"&gt;@drawable/screen_background_white&lt;/item&gt;
   &lt;item name="panelForegroundColor"&gt;#FF000000&lt;/item&gt;
   &lt;item name="panelBackgroundColor"&gt;#FFFFFFFF&lt;/item&gt;
   &lt;item name="panelTextColor"&gt;?panelForegroundColor&lt;/item&gt;
   &lt;item name="panelTextSize"&gt;14&lt;/item&gt;
   &lt;item name="menuItemTextColor"&gt;?panelTextColor&lt;/item&gt;
   &lt;item name="menuItemTextSize"&gt;?panelTextSize&lt;/item&gt;
&lt;/style&gt;
</pre>
<p>
    Notice that, to reference a value from the currently loaded theme, we use 
    a question-mark (?) instead of the at-symbol (@), in the reference string. 
    You must refer to such a specific <code>&lt;item&gt;</code> by its name in 
    the currently loaded theme. This can be used in XML resources only. 
</p>

<p>
    <strong>Example Code Use of a Theme</strong>
</p>
<p>
    The following Java snippet demonstrates loading a style set (i.e., a theme).
</p>
<pre>
setTheme(R.style.ThemeNew);
</pre>
<p>
    The following XML applies an Android theme to a whole file (in this case, the Android dialog theme, to make the screen a floating dialog screen).
</p>
<pre>
&lt;!-- AndroidManifest.xml --&gt;
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.example.codelab.rssexample"&gt;
       &lt;activity class="AddRssItem" android:label="@string/add_item_label" android:theme="@android:style/Theme.Dialog"/&gt;
&lt;/manifest&gt;
</pre>
