'\" t
.\" @(#)keytool.1 1.9 00/06/19 SMI;
.\" Copyright 2004 Sun Microsystems, Inc. All rights reserved.
.\" Copyright 2004 Sun Microsystems, Inc. Tous droits r駸erv駸.
.\" 
.TH keytool 1 "2004 年 6 月 22 日"
.SH "名前"
keytool \- 鍵と証明書の管理ツール
.SH "形式"
.B keytool
[
.IR commands " ]"
.SH "機能説明"
.IX "key and certificate management tool" "" "key and certificate management tool \(em \fLkeytool\fP"
.IX "keytool" "" "\fLkeytool\fP \(em key and certificate management tool"
.B keytool
は、鍵と証明書を管理するためのユーティリティです。keytool を使うと、自分の
公開鍵と非公開鍵のペア、および関連する証明書を管理し、デジタル署名を
使った自己認証 (ほかのユーザまたはサービスに対して自分自身を認証する
こと) や、データの完全性と認証に関するサービスに利用することができます。
keytool では、通信相手の公開鍵を (証明書の形で) キャッシュすることもでき
ます。 
.LP
「証明書」とは、あるエンティティからのデジタル署名付きの文書のことです。
証明書には、ほかのあるエンティティ (人物、会社など) の公開鍵 (およびその
他の情報) が特別な値を持っていることが書かれています (「証明書」を参照)。
データにデジタル署名が付いている場合は、デジタル署名を検証することで、
データの完全性およびデータが本物であることをチェックできます。データの
「完全性」とは、データが変更されたり、改変されたりしていないことを意味します。
また、データが「本物である」とは、そのデータが、データを作成して署名したと
称する人物から実際に渡されたデータであることを意味します。 
.LP
.B keytool
は、鍵と証明書を「キーストア」に格納します。デフォルトのキーストアの実装は、
キーストアをファイルとして実装しています。キーストアは、非公開鍵をパスワード
で保護します。 
.LP
.BR jarsigner (1)
ツールは、キーストアの情報を使って Java Archive (JAR) ファイルに対するデジタル署名の生成と検証を行います。JAR ファイルは、
クラスファイル、イメージ、サウンド、およびその他のデジタルデータを単一のファ
イルにパッケージ化します。
.BR jarsigner (1)
は、JAR ファイルに付属する証明書 (JAR 
ファイルの署名ブロックファイルに含まれている証明書) を使って JAR ファイルの
デジタル署名を検証し、証明書の公開鍵が「信頼」できるかどうか、つまり、該当
する公開鍵が、指定されたキーストアに含まれているかどうかを調べます。 
.LP
注: 
.B keytool
ツールと
.BR jarsigner (1)
ツールは、JDK 1.1 で提供されていた javakey ツールを完全に置き換えるもの
です。これらの新しいツールは javakey よりも多くの機能を備えており、キースト
アと非公開鍵をパスワードで保護する機能や、署名の生成に加えて署名を検証
する機能を持っています。新しいキーストアアーキテクチャは、javakey が作成し
て管理していたアイデンティティデータベースに代わるものです。
.B -identitydb
サブコマンドを使うと、アイデンティティデータベースの情報をキーストアにインポートできます。 
.LP
.SS "キーストアのエントリ"
.IX "keytool" "Keystore Entries" "\fLkeytool\fP \(em key and certificate management tool"
.LP
キーストアのエントリには、次の 2 つの種類があります。 
.TP 5
1. 
鍵のエントリ - 各エントリは、非常に重要な暗号化の鍵の情報を保持します。
この情報は、許可していないアクセスを防ぐために、保護された形で格納されま
す。一般に、この種のエントリとして格納される鍵は、秘密鍵か、対応する公開鍵
の証明連鎖を伴う非公開鍵です。
.B keytool
ツールと 
.BR jarsigner (1)
ツールはこのうち後者の方、つまり非公開鍵および関連する証明連鎖だけを扱
います。
.TP 5
2. 
信頼できる証明書のエントリ - 各エントリは、第三者からの公開鍵証明書を 
1 つ含んでいます。この証明書は、「信頼できる証明書」と呼ばれます。それは、
証明書内の公開鍵が、証明書の「主体」(所有者) によって特定されるアイデンティ
ティに由来するものであることを、キーストアの所有者が信頼するからです。
証明書の発行者は、証明書に署名を付けることによって、その内容を保証します。 
.LP
.SS "キーストアの別名"
.IX "keytool" "Keystore Aliases" "\fLkeytool\fP \(em key and certificate management tool"
.LP
キーストアのすべてのエントリ (鍵および信頼できる証明書) は、一意の「別名」
を介してアクセスされます。別名では、大文字と小文字は区別されません。
したがって、別名 Hugo と hugo は、どちらも同じキーストアエントリを指します。 
.LP
.B -genkey
サブコマンドを使って鍵のペア (公開鍵と非公開鍵) を生成したり、
.B -import
サブコマンドを使って、信頼できる証明書のリストに証明書または証明連鎖を追加
するなど、キーストアにエンティティを追加するときは、別名を指定します。これ以後、
.B keytool
コマンドでエンティティを参照する場合は、このときに指定した別名を使用する
必要があります。 
.LP
たとえば、duke という別名を使って新しい公開鍵と非公開鍵のペアを生成し、
公開鍵を自己署名証明書 (「証明連鎖」を参照) でラップするとします。この場合は、
次のコマンドを実行します。 
.LP
.ft 3
.nf
keytool \-genkey \-alias duke \-keypass dukekeypasswd
.fi
.ft 1
.LP
ここでは、初期パスワードとして 
.B dukekeypasswd
を指定しています。以後、別名
.BR duke
に関連付けられた非公開鍵にアクセスするコマンドを実行するときは、このパス
ワードが必要になります。
.BR duke
の非公開鍵のパスワードをあとから変更するに
は、次のコマンドを実行します。 
.LP
.ft 3
.nf
.if t keytool \-keypasswd \-alias duke \-keypass dukekeypasswd \-new newpass
.if n keytool \-keypasswd \-alias duke \-keypass\\
.if n		 dukekeypasswd \-new newpass
.fi
.ft 1
.LP
パスワードが、dukekeypasswd から newpass に変更されます。 
.LP
注: テストを目的とする場合、または安全であることがわかっているシステムで
実行する場合以外は、コマンド行やスクリプトでパスワードを指定しないでくださ
い。必要なパスワードのオプションをコマンド行で指定しなかった場合は、パス
ワードの入力を求められます。password プロンプトでパスワードを入力すると、
入力したパスワードがエコーされ、そのまま画面に表示されます。このため、周
囲にほかのユーザがいる場合は、パスワードを見られないように注意してください。 
.LP
.SS "キーストアの場所"
.IX "keytool" "Keystore Location" "\fLkeytool\fP \(em key and certificate management tool"
.LP
.B keytool
の各コマンドには、
.B -keystore
オプションがあります。このオプションでは、
.BR keytool 
で管理するキーストアに対応する永続的なキーストアファイルの名前と場所を
指定します。キーストアは、デフォルトではユーザのホームディレクトリの 
.B .keystore
という名前のファイルに格納されます。ユーザのホームディレクトリは、
user.home システムプロパティによって決まります。
.LP
.B \-keystore 
オプションからの入力ストリームは
KeyStore.load メソッドに
渡されることに注意してください。URL として NONE が指定されている場合は、
NULL ストリームが KeyStore.load メソッドに
渡されます。たとえば、ハードウェアトークンデバイス上に
存在する場合など、
キーストアがファイルベースでない場合は、NONE を指定する必要があります。
.SS "キーストアの作成"
.IX "keytool" "Keystore Creation" "\fLkeytool\fP \(em key and certificate management tool"
.LP
まだ存在していないキーストアに対し、
.BR -genkey
、
.BR -import
、または
.B -identitydb
サブコマンドを使ってデータを追加すると、キーストアが作成されます。 
.LP
具体的には、
.B -keystore
オプションでキーストアを指定していて、このキーストアがまだ存在していない
場合は、指定したキーストアが作成されます。 
.LP
.B -keystore
オプションを指定しなかった場合、デフォルトのキーストアは、ホームディレクトリ
内の
.B .keystore
という名前のファイルになります。このファイルがまだ存在していない場合は作成
されます。 
.LP
.SS "キーストアの実装"
.IX "keytool" "Keystore Implementation" "\fLkeytool\fP \(em key and certificate management tool"
.LP
java.security パッケージで提供される 
.B KeyStore
クラスには、キーストア内の情報に対するアクセスと変更を行うための明確に
定義されたインタフェースが用意されています。キーストアの固定実装としては、
それぞれが特定の「タイプ」のキーストアを対象とする複数の異なる実装が存在
可能です。 
.LP
現在、\f3keytool\fP と 
.BR jarsigner (1)
の 2 つのコマンド行ツールと、
.B policytool
という名前の 1 つの GUI ベースの
ツールがあります。
.B KeyStore
は public として使用可能なので、JDK ユーザは 
.B KeyStore
を使ったほかのセキュリティアプリケーションも作成できます。 
.LP
キーストアには、Sun が提供する組み込みのデフォルトの実装があります。
これは、JKS という名前の独自のキーストアタイプ (形式) を利用するもので、
キーストアをファイルとして実装しています。この実装では、個々の非公開鍵は
個別のパスワードによって保護され、キーストア全体の完全性も (非公開鍵とは
別の) パスワードによって保護されます。 
.LP
キーストアの実装は、プロバイダベースです。具体的には、
.B KeyStore
が提供するアプリケーションインタフェースは、Service Provider Interface (SPI) 
という形で実装されています。つまり、対応する 
.B KeystoreSpi
抽象クラス (これも java.security パッケージに含まれている) があり、このクラス
が Service Provider Interface のメソッドを定義しています。これらのメソッドは、
「プロバイダ」が実装しなければなりません。ここで、「プロバイダ」とは、
Java Security API によってアクセス可能なサービスのサブセットに対し、その
固定実装を提供するパッケージまたはパッケージの集合のことです。したがって、
キーストアの実装を提供するには、「Java 暗号化アーキテクチャ用プロバイダの
実装方法」で説明しているように、クライアントが「プロバイダ」を実装し、
.B KeystoreSpi
サブクラスの実装を提供する必要があります。 
.LP
アプリケーションでは、
.B KeyStore
クラスが提供する getInstance ファクトリメソッドを使うことで、さまざまなプロバイダ
から異なる「タイプ」のキーストアの実装を選択できます。キーストアのタイプは、
キーストア情報の格納形式とデータ形式、およびキーストア内の非公開鍵と
キーストア自体の完全性を保護するために使われるアルゴリズムを定義します。
異なるタイプのキーストアの実装には、互いに互換性はありません。 
.LP
.B keytool
は、任意のファイルベースのキーストア実装で動作します。
.B keytool
は、コマンド行から渡されたキーストアの場所をファイル名として扱い、これを 
FileInputStream に変換して、FileInputStream からキーストアの情報をロード
します。一方、
.BR jarsigner (1)
ツールと policytool ツールは、URL で指定可能な任意の場所からキーストアを
読み込むことができます。 
.LP
.B keytool
と
.BR jarsigner (1)
の場合、
.B -storetype
オプションを使ってコマンド行でキーストアのタイプを指定できます。
.B Policy Tool
の場合は、[Edit] メニューの [Change Keystore] コマンドを使って
キーストアのタイプを指定できます。 
.LP
キーストアのタイプを明示的に指定しない場合、keytool、jarsigner、および 
policytool の各ツールは、セキュリティプロパティファイル内で指定された 
keystore.type プロパティの値に基づいてキーストアの実装を選択します。
セキュリティプロパティファイルは、
.BR java.security
という名前で JDK セキュリティプロパティディレクトリ 
.BR java.home/lib/security
に置かれています。java.home は、JDK のインストール先ディレクトリです。 
.LP
各ツールは、keystore.type の値を取得し、この値で指定されたタイプのキースト
アを実装しているプロバイダが見つかるまで、現在インストールされているすべて
のプロバイダを調べます。目的のプロバイダが見つかると、そのプロバイダからの
キーストアの実装を使います。 
.LP
.B KeyStore
クラスでは getDefaultType という名前の static メソッドが定義されており、
アプリケーションとアプレットはこのメソッドを使うことで 
.B keystore.type 
プロパティの値を取得できます。次のコードは、デフォルトのキーストアタイプ (
.B keystore.type
プロパティで指定されたタイプ) のインスタンスを生成します。 
.LP
.ft 3
.nf
KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
.fi
.ft 1
.LP
デフォルトのキーストアタイプは jks (Sun が提供する独自のタイプのキーストア
の実装) です。これは、セキュリティプロパティファイル内の次の行によって指定
されています。 
.LP
.ft 3
.nf
keystore.type=jks
.fi
.ft 1
.LP
各ツールでデフォルト以外のキーストアの実装を使用するには、上の行を
変更して別のキーストアのタイプを指定します。 
.LP
たとえば、pkcs12 と呼ばれるタイプのキーストアの実装を提供している
プロバイダパッケージを使用するには、上の行を次のように変更します。 
.LP
.ft 3
.nf
keystore.type=pkcs12
.fi
.ft 1
.LP
注: キーストアのタイプの指定では、大文字と小文字は区別されません。
たとえば、JKS と jks は同じものとして扱われます。 
.LP
.SS "サポートされるアルゴリズムと鍵のサイズ"
.IX "keytool" "Supported Algorithms and Key Sizes" "\fLkeytool\fP \(em key and certificate management tool"
.LP
.B keytool
では、登録されている暗号化サービスプロバイダが提供する鍵のペア生成およ
び署名アルゴリズムのうち、任意のアルゴリズムを指定できます。つまり、さまざま
なコマンドで指定する 
.B -keyalg
オプションと
.B -sigalg
オプションは、プロバイダ実装によってサポートされていなければなりません。
デフォルトの鍵のペア生成アルゴリズムは DSA です。署名アルゴリズムは、基に
なる非公開鍵のアルゴリズムから派生します。基になる非公開鍵が DSA タイプ
である場合、デフォルトの署名アルゴリズムは SHA1withDSA になり、基になる
非公開鍵が RSA タイプである場合は、デフォルトの署名アルゴリズムは 
MD5withRSA になります
.LP
DSA 鍵のペアを生成する場合、鍵のサイズは 512 〜 1024 ビットである必要が
あります。また、鍵のサイズは、64 の倍数である必要があります。デフォルトの鍵
のサイズは、どのアルゴリズムの場合でも 1024 ビットです。 
.LP
.SS "証明書"
.IX "keytool" "Certificates" "\fLkeytool\fP \(em key and certificate management tool"
.LP
証明書 (公開鍵証明書とも呼ぶ) とは、あるエンティティ (「発行者」) からの
デジタル署名付きの文書のことです。証明書には、ほかのあるエンティティ (
「署名者」) の公開鍵 (およびその他の情報) が特別な値を持っていることが
書かれています。 
.LP
以下では、いくつかの重要な用語について説明します。 
.TP 15
.B 公開鍵
公開鍵は、特定のエンティティに関連付けられた数です。公開鍵は、
該当するエンティティとの間に信頼できる関係を持つ必要があるすべて
の人に対して公開することを意図したものです。公開鍵は、署名を検証
するのに使われます。 
.TP
.B デジタル署名 
データが「デジタル署名」されると、そのデータは、エンティティの
「アイデンティティ」と、そのエンティティがデータの内容について知っている
ことを証明する署名とともに格納されます。エンティティの非公開鍵を使って
データに署名を付けると、データの偽造は不可能になります。 
.TP
.B アイデンティティ 
エンティティを特定するための既知の方法です。システムによっては、
公開鍵をアイデンティティにするものがあります。公開鍵のほかにも、Unix 
UID や電子メールアドレス、X.509 識別名など、さまざまなものをアイデンティ
ティとすることができます。 
.TP
.B 署名
署名は、なんらかのデータを基にエンティティ (署名者。証明書に関しては
発行者とも呼ばれる) の非公開鍵を使って計算されます。 
.TP
.B 非公開鍵
非公開鍵は特定のエンティティだけが知っている数のことで、この数のことを、
そのエンティティの非公開鍵といいます。非公開鍵は、ほかに知られないように
秘密にしておくことが前提になっています。どのような「公開鍵暗号化システム」
でも、非公開鍵と公開鍵が対 (ペア) で存在します。DSA などの典型的な公
開鍵暗号化システムの場合、1 つの非公開鍵は正確に 1 つの公開鍵に対応
します。非公開鍵は、署名を計算するのに使われます。 
.TP
.B エンティティ
エンテンティは、人、組織、プログラム、コンピュータ、企業、銀行など、
一定の度合いで信頼の対象となるさまざまなものを指します。 
.LP
公開鍵暗号化では、その性質上、ユーザの公開鍵にアクセスする必要が
あります。大規模なネットワーク環境では、互いに通信しているエンティティ
間で以前の関係が引き続き確立されていると仮定したり、使われているす
べての公開鍵を収めた信頼できるリポジトリが存在すると仮定したりするこ
とは不可能です。証明書は、このような公開鍵配布の問題に対する解決
策として考案されました。「証明書発行局」(CA) は、信頼できる第三者とし
て機能します。CA は、ほかのエンティティの証明書に署名する (発行する) 
行為を、信頼して任されているエンティティ (企業など) です。CA は法律上
の契約に拘束されるので、有効かつ信頼できる証明書だけを作成するもの
として扱われます。VeriSign、Thawte、Entrust をはじめ、多くの CA が存在
します。Netscape (TM) や Microsoft の認証サーバ、Entrust の CA 製品など
を所属組織内で利用すれば、独自の証明書発行局を運営することも可能です。 
.LP
.BR keytool
を使うと、証明書の表示、インポート、およびエクスポートを行うことができます。
また、自己署名証明書を生成することもできます。 
.LP
現在、
.B keytool 
は X.509 証明書を対象にしています。 
.LP
.SS "X.509 証明書"
.IX "keytool" "X.509 Certificates" "\fLkeytool\fP \(em key and certificate management tool"
.LP
X.509 規格では、証明書に含める情報が定義されており、この情報を証明書に
書き込む方法 (データ形式) についても記述されています。すべての X.509 
証明書は、署名のほかに次のデータを含んでいます。 
.if t .TP 20
.if n .TP 15
バージョン \(em 証明書に適用される X.509 規格のバージョンを特定します。証明書に指定で
きる情報は、バージョンによって異なります。これまでに、3 つのバージョンが定義
されています。
.B keytool
では、v1、v2、および v3 の証明書のインポートとエクスポートが可能です。
.B keytool
が生成するのは、v1 の証明書です。 
.if t .TP 20
.if n .TP 15
シリアル番号 \(em 証明書を作成したエンティティは、そのエンティティが
発行するほかの証明書と
区別するために、証明書にシリアル番号を割り当てます。この情報は、さまざま
な方法で使われます。たとえば、証明書が取り消されると、シリアル番号が証明
書の取り消しリスト (CRL) に格納されます。 
.if t .TP 20
.if n .TP 15
署名アルゴリズム識別子  \(em 証明書に署名を付けるときに CA が使っ
たアルゴリズムを特定します。 
.if t .TP 20
.if n .TP 15
発行者名 \(em 証明書に署名を付けたエンティティの X.500 識別名
です。エンティティは、
通常は CA です。この証明書を使うことは、証明書に署名を付けたエンティティ
を信頼することを意味します。「ルート」つまりトップレベルの CA の証明書など、
場合によっては発行者が自身の証明書に署名を付けることがある点に注意して
ください。 
.if t .TP 20
.if n .TP 15
有効期間 \(em 各証明書は、限られた期間だけ有効になります。
この期間は開始の日時と終了
の日時によって指定され、数秒の短い期間から 100 年という長期にわたることも
あります。有効期間は、証明書の署名に使われた非公開鍵の強度や証明書に
対して支払われる金額など、さまざまな要因を考慮して選択されます。関連付け
られている非公開鍵が他人に知られない限り、エンティティが証明書を信頼でき
る期間が有効期間です。 
.if t .TP 20
.if n .TP 15
主体名 \(em 証明書に関連付けられた公開鍵を所有しているエンティティ
の名前です。
インターネット上で一意の名前にするため、この名前には X.500 規格が使われ
ます。これは、エンティティの X.500 識別名 (DN) です。たとえば、次のようにな
ります。 
.LP
.ft 3
.nf
CN=Java Duke, OU=Java Software Division, O=Sun Microsystems Inc, C=US
.fi
.ft 1
.LP
これらはそれぞれ主体の通称、組織単位、組織、国を表します。 
.if t .TP 20
.if n .TP 15
主体の公開鍵情報 \(em 名前を付けられたエンティティの公開鍵と
アルゴリズム識別子です。
アルゴリズム識別子では、公開鍵に対して使われている公開鍵暗号化システム
および関連する鍵パラメータが指定されています。 
.LP
.I X.509 Version 1 
は、1988 年から利用されて広く普及しており、もっとも一般的です。 
.LP
.I X.509 Version 2 
では、主体や発行者の名前をあとで再利用できるようにするために、主体と
発行者とに一意識別子の概念が導入されました。ただし、ほとんどの証明書
プロファイル文書では、名前の再利用および証明書での一意識別子の利用
を推奨していません。Version 2 の証明書は、広く普及しているとはいえません。 
.LP
.I  X.509 Version 3 
はもっとも新しい (1996 年) 規格で、エクステンションの概念をサポートして
います。エクステンションは誰でも定義することができ、証明書に含めること
ができます。現在使われている一般的なエクステンションとしては、KeyUsage 
(「署名専用」など、鍵の使用を特定の目的に制限する)、AlternativeNames 
(たとえば、DNS 名、電子メールアドレス、IP アドレスなど、ほかのアイデンティ
ティを公開
鍵に関連付けることができる) などがあります。エクステンションには、critical 
というマークを付けて、そのエクステンションのチェックと使用を義務づけること
ができます。たとえば、critical とマークされ、KeyCertSign が設定された 
KeyUsage エクステンションが証明書に含まれている場合、この証明書を SSL 
通信中に提示すると、証明書が拒否されます。これは、証明書のエクステンシ
ョンによって、関連する非公開鍵が証明書の署名専用として指定されており、SSL では使用できないためです。 
.LP
証明書のすべてのデータは、ASN.1/DER と呼ばれる 2 つの関連規格を
使って符号化されます。「
.I Abstract Syntax Notation 1
」はデータについて記述しています。「Definite Encoding Rules」は、データの
保存および転送の方法について記述しています。 
.LP
.SS "X.500 識別名"
.IX "keytool" "X.500 Distinguished Names" "\fLkeytool\fP \(em key and certificate management tool"
.LP
X.500 識別名は、エンティティを特定するために使われます。たとえば、X.509 
証明書の subject フィールドと issuer (署名者) フィールドで指定される名前は、
X.500 識別名です。
.B keytool
は、次のサブパートをサポートしています。 
.TP 2
\(bu
commonName\(em人の通称。「Susan Jones」など
.TP 2
\(bu
organizationUnit\(em小さな組織 (部、課など) の名称。「仕入部」など
.TP 2
\(bu 
organizationName\(em大きな組織の名称。「ABCSystems, Inc.」など
.TP 2
\(bu
localityName\(em地域 (都市) 名。「Palo Alto」など
.TP 2
\(bu
stateName\(em州名または地方名。「California」など
.TP 2
\(bu
country\(em2 文字の国番号。「CH」など
.LP
.B -genkey
サブコマンドまたは
.B -selfcert
サブコマンドの 
.B -dname
オプションの値として識別名文字列を指定する場合は、次の形式で指定
する必要があります。 
.LP
.ft 3
.nf
CN=cName, OU=orgUnit, O=org, L=city, S=state, C=countryCode
.fi
.ft 1
.LP
イタリック体の項目は、実際に指定する値を表します。短縮形のキーワードの
意味は、次のとおりです。 
.LP
.ft 3
.nf
CN=commonName
OU=organizationUnit
O=organizationName
L=localityName
S=stateName
C=country
.fi
.ft 1
.LP
次に示すのは、識別名文字列の例です。 
.LP
.ft 3
.nf
CN=Mark Smith, OU=Java, O=Sun, L=Cupertino, S=California, C=US
.fi
.ft 1
.LP
次は、この文字列を使ったコマンドの例です。 
.LP
.ft 3
.nf
keytool \-genkey \-dname "CN=Mark Smith, OU=Java, 
O=Sun, L=Cupertino, S=California, C=US" -alias mark
.fi
.ft 1
.LP
キーワードの短縮形では、大文字と小文字は区別されません。たとえば、
.BR CN 
、
.BR cn 
、および
.B Cn
は、どれも同じものとして扱われます。 
.LP
一方、キーワードの指定順序には意味があり、各サブコンポーネントは上に
示した順序で指定する必要があります。ただし、サブコンポーネントをすべて
指定する必要はありません。たとえば、次のように一部のサブコンポーネント
だけを指定できます。 
.LP
.ft 3
.nf
CN=Steve Meier, OU=SunSoft, O=Sun, C=US
.fi
.ft 1
.LP
識別名文字列の値にコンマが含まれる場合にコマンド行の文字列を指定する
ときには、次のように、コンマを \\ 文字でエスケープする必要があります。 
.LP
.ft 3
.nf
cn=peter schuster, o=Sun Microsystems\\, Inc., o=sun, c=us
.fi
.ft 1
.LP
識別名文字列をコマンド行で指定する必要はありません。識別名を必要とする
コマンドを実行するときに、コマンド行で識別名を指定しなかった場合は、各
サブコンポーネントの入力を求められます。この場合は、コンマを \\ 文字で
エスケープする必要はありません。 
.LP
.SS "インターネット RFC 1421 証明書エンコーディング"
.IX "keytool" "The Internet RFC 1421 Certificate Encoding Standard" "\fLkeytool\fP \(em key and certificate management tool"
.LP
多くの場合、証明書は、バイナリエンコーディングではなく、インターネット 
RFC 1421 規格で定義されているプリント可能エンコーディング方式を使って
格納されます。「Base 64 エンコーディング」とも呼ばれるこの証明書形式では、
電子メールやその他の機構を通じて、ほかのアプリケーションに証明書を容易
にエクスポートできます。 
.LP
.B -import
サブコマンドと 
.B -printcert
サブコマンドでは、この形式の証明書とバイナリエンコーディングの証明書を
読み込むことができます。 
.LP
.B -export
サブコマンドでは、デフォルトでバイナリエンコーディングの証明書が出力されます。
ただし、
.B -rfc
オプションを指定した場合は、プリント可能エンコーディング方式の証明書が
出力されます。 
.LP
.B -list
サブコマンドでは、デフォルトで証明書の MD5 フィンガープリントが出力されます。
.B -v
オプションを指定すると、人間が読むことのできる形式で証明書が出力されます。
一方、
.B -rfc
オプションを指定すると、プリント可能エンコーディング方式で証明書が出力され
ます。 
.LP
プリント可能エンコーディング方式で符号化された証明書は、次の行で始まります。 
.LP
.ft 3
.nf
-----BEGIN CERTIFICATE-----
.fi
.ft 1
.LP
最後は、次の行で終わります。 
.LP
.ft 3
.nf
-----END CERTIFICATE-----
.fi
.ft 1
.LP
.SS "証明連鎖"
.IX "keytool" "Certificate Chains" "\fLkeytool\fP \(em key and certificate management tool"
.LP
.B keytool
では、非公開鍵および関連する証明「連鎖」を含むキーストアの「鍵」エントリを
作成し、管理することができます。このようなエントリでは、非公開鍵に対応する
公開鍵は、連鎖の最初の証明書に含まれています。 
.LP
鍵を初めて作成すると (
.B -genkey
サブコマンドを参照)、「自己署名証明書」という 1 つの要素だけを含む連鎖が開始
されます。自己署名証明書とは、発行者 (署名者) と主体 (証明書によって認証
される公開鍵を所有しているエンティティ) とが同一の証明書のことです。
.B -genkey
サブコマンドを呼び出して新しい公開鍵と非公開鍵のペアを作成すると、公開鍵は
常に自己署名証明書でラップされます。 
.LP
このあと、証明書署名要求 (CSR) が生成されて (
.B -certreq
サブコマンドを参照)、CSR が証明書発行局 (CA) に送信されると、CA からの
応答がインポートされ (
.BR -import
コマンドを参照)、元の自己署名証明書は証明連鎖によって置き換えられます。
連鎖の最後にあるのは、主体の公開鍵を認証した CA が発行した証明書 (応答) 
です。連鎖内のその前の証明書は、「CA」の公開鍵を認証する証明書です。 
.LP
CA の公開鍵を認証する証明書は、多くの場合、自己署名証明書 (つまり CA 
が自身の公開鍵を認証した証明書) であり、これは連鎖の最初の証明書になり
ます。場合によっては、CA が証明の連鎖を返すこともあります。この場合、連鎖
内の最後の証明書 (CA によって署名され、鍵エントリの公開鍵を認証する証
明書) に変わりはありませんが、連鎖内のその前の証明書は、CSR の送信先
の CA とは「別の」CA によって署名され、CSR の送信先の CA の公開鍵を認
証する証明書になります。さらに、連鎖内のその前の証明書は、次の CA の鍵
を認証する証明書になります。以下同様に、自己署名された「ルート」証明書に
達するまで連鎖が続きます。したがって、連鎖内の (最初の証明書以後の) 
各証明書では、連鎖内の次の証明書の署名者の公開鍵が認証されているこ
とになります。 
.LP
多くの CA は、連鎖をサポートせずに発行済みの証明書だけを返します。
特に、中間の CA が存在しないフラットな階層構造の場合は、その傾向が
顕著です。このような場合は、キーストアにすでに格納されている信頼でき
る証明書情報から、証明連鎖を確立する必要があります。 
.LP
別の応答形式 (PKCS#7 で定義されている形式) でも、発行済み証明書に
加え、証明書連鎖のサポートが含まれています。
.BR keytool
では、どちらの応答形式も扱うことができます。 
.LP
トップレベル (ルート) CA の証明書は、自己署名証明書です。ただし、ルートの
公開鍵に対する信頼は、ルートの証明書自体から導き出されるものではなく 
(たとえば、VeriSign ルート CA のような有名な識別名を使った自己署名証明書
を作成すること自体は誰でも可能)、新聞などのほかの情報源に由来するもので
す。ルート CA の公開鍵は広く知られています。ルート CA の公開鍵を証明書
に格納する理由は、証明書という形式にすることで多くのツールから利用できる
ようになるからにすぎません。つまり、証明書は、ルート CA の公開鍵を運ぶ
「媒体」として利用されるだけです。ルート CA の証明書をキーストアに追加す
るときは、その前に証明書の内容を表示し (-printcert オプションを使用)、表示
されたフィンガープリントと、新聞やルート CA の Web ページなどから入手した
既知のフィンガープリントとを比較する必要があります。 
.LP
.SS "証明書のインポート"
.IX "keytool" "Importing Certificates" "\fLkeytool\fP \(em key and certificate management tool"
.LP
証明書をファイルからインポートするには、
.B -import
サブコマンドを使います。たとえば、次のようにします。 
.LP
.ft 3
.nf
keytool \-import \-alias joe \-file jcertfile.cer
.fi
.ft 1
.LP
この例は、ファイル
.I jcertfile.cer
の証明書をインポートし、別名
.BR joe
によって特定されるキーストアエントリに証明書を格納します。 
.LP
証明書のインポートには、次の 2 つの目的があります。 
.TP 5
1. 
信頼できる証明書のリストに証明書を追加する
.TP 5
2. 
CA に証明書署名要求 (
.B -certreq
サブコマンドを参照) を送信した結果として、CA から受け取った証明書応答を
インポートする 
.LP
どちらの種類のインポートを行うかは、
.B -alias
オプションの値によって指定します。
.LP
.TP 2
\(bu 別名が鍵エントリを指している場合、
.B keytool 
は証明書応答をインポートするものと
みなします。
.B keytool 
は証明書応答の
公開鍵が別名で保存されている
公開鍵と一致するかどうかを
確認し、異なる場合は終了します。
.LP
.TP 2
\(bu 別名が鍵エントリを指していない場合、
.B keytool 
は信頼できる証明書エントリを追加するものと
みなします。この場合、
別名がキーストア内にまだ存在していない必要があります。
別名がすでに存在する場合、
.B keytool 
はエラーを
出力します。これは、
その別名の信頼できる証明書が
すでに存在し、
証明書をインポートしないためです。
別名がキーストア内に存在しない場合、
.B keytool 
は指定された別名で
信頼できる証明書エントリを
作成し、インポートした証明書に
関連付けます。 
.LP
.ft 3
信頼できる証明書のインポートに関する注意事項
.LP
重要: 信頼できる証明書として証明書をインポートする前に、証明書の
内容を慎重に調べてください。 
.ft 1
.LP
まず、証明書の内容を表示し (
.B -printcert
サブコマンドを使用するか、または
.B -noprompt
オプションを指定しないで 
.B -import
サブコマンドを使用)、表示された証明書のフィンガープリントが、期待されるフィン
ガープリントと一致するかどうかを確認します。たとえば、あるユーザから証明書
が送られてきて、この証明書を
.BR /tmp/cert 
という名前でファイルに格納しているとします。この場合は、信頼できる証明書の
リストにこの証明書を追加する前に、
.B -printcert
サブコマンドを実行してフィンガープリントを表示できます。たとえば、次のようにし
ます。 
.LP
.ft 3
.nf
keytool -printcert -file /tmp/cert
Owner: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
Issuer: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
Serial Number: 59092b34
Valid from: Thu Sep 25 18:01:13 PDT 1997 until: Wed Dec 24 17:01:13 PST 1997
Certificate Fingerprints:
MD5:  11:81:AD:92:C8:E5:0E:A2:01:2E:D4:7A:D7:5F:07:6F
SHA1: 20:B6:17:FA:EF:E5:55:8A:D0:71:1F:E8:D6:9D:C0:37:13:0E:5E:FE
.fi
.ft 1
.LP
次に、証明書を送信した人物に連絡し、この人物が提示したフィンガープリント
と、上のコマンドで表示されたフィンガープリントとを比較します。フィンガープ
リントが一致すれば、送信途中でほかの何者か (攻撃者など) による証明書の
すり替えが行われていないことを確認できます。送信途中でこの種の攻撃が行
われていた場合、チェックを行わずに証明書をインポートすると、攻撃者によっ
て署名されたすべてのもの (攻撃的意図を持つクラスファイルを含んだ JAR フ
ァイルなど) を信頼することになります。
.LP
注: 証明書をインポートする前に必ず
.B -printcert
サブコマンドを実行しなければならないわけではありません。
.B -import
サブコマンドを実行すると、キーストア内の信頼できる証明書のリストに証明書を
追加する前に、証明書の情報が表示され、確認を求めるメッセージが表示され
ます。インポート操作は、この時点で中止できます。ただし、確認メッセージが表
示されるのは、
.B -import
サブコマンドを
.B -noprompt
オプションを指定せずに実行した場合だけです。
.B -noprompt
オプションが指定されている場合、ユーザとの対話は行われません。 
.LP
.SS "証明書のエクスポート"
.IX "keytool" "Exporting Certificates" "\fLkeytool\fP \(em key and certificate management tool"
.LP
証明書をファイルにエクスポートするには、
.B -export
サブコマンドを使います。たとえば、次のようにします。 
.LP
.ft 3
.nf
keytool \-export \-alias jane \-file janecertfile.cer
.fi
.ft 1
.LP
この例は、
.B jane
の証明書をファイル
.IR janecertfile.cer
にエクスポートします。
.B jane
が鍵エントリの別名である場合は、指定されたキーストアエントリの証明連鎖の
最後の証明書をエクスポートします。この証明書は、
.B jane
の公開鍵を認証する証明書です。 
.LP
一方、
.B jane
が、信頼できる証明書のエントリの別名である場合は、該当する信頼できる
証明書がエクスポートされます。 
.LP
.SS "証明書の表示"
.IX "keytool" "Displaying Certificates" "\fLkeytool\fP \(em key and certificate management tool"
.LP
キーストアエントリの内容を表示するには、
.B -list
サブコマンドを使います。たとえば、次のようにします。 
.LP
.ft 3
.nf
keytool \-list \-alias joe
.fi
.ft 1
.LP
次は、別名を指定しない例です。 
.LP
.ft 3
.nf
keytool \-list
.fi
.ft 1
.LP
別名を指定しない場合は、キーストア全体の内容が表示されます。 
.LP
ファイルに格納されている証明書の内容を表示するには、
.B -printcert
サブコマンドを使います。たとえば、次のようにします。 
.LP
.ft 3
.nf
keytool \-printcert \-file certfile.cer
.fi
.ft 1
.LP
この例では、ファイル
.IR certfile.cer
に格納されている証明書の情報が表示されます。 
.LP
注: このコマンドは、キーストアとは関係なく動作します。つまり、キーストアが
ない場合でも、ファイルに格納された証明書を表示できます。 
.LP
.SS "自己署名証明書の生成"
.IX "keytool" "Generating a Self-signed Certificate" "\fLkeytool\fP \(em key and certificate management tool"
.LP
「自己署名証明書」とは、発行者 (署名者) と主体 (証明書によって認証される
公開鍵を所有しているエンティティ) とが同一の証明書のことです。
.B -genkey
サブコマンドを呼び出して新しい公開鍵と非公開鍵のペアを作成すると、公開鍵は
常に自己署名証明書でラップされます。 
.LP
場合によっては、新しい自己署名証明書を作成したいことがあります。
たとえば、同じ鍵のペアを別のアイデンティティ (識別名) で使いたい場合など
です。例として、所属部課が変更になったとします。この場合は、次のようにし
ます。 
.TP 5
1. 
元の鍵エントリをコピー (複製) する (
.BR -keyclone
を参照)
.TP
2.
新しい識別名を使って、複製したエントリの新しい自己署名証明書を
生成する (以下を参照)
.TP
3. 
複製したエントリの証明書署名要求を生成し、応答として送られてきた証明書
または証明連鎖をインポートする (
.B -certreq
サブコマンドと
.B -import
サブコマンドを参照)
.TP
4.
元の (不要になった) エントリを削除する (
.BR -delete 
コマンドを参照)
.LP
自己署名証明書を生成するには、
.B -selfcert
サブコマンドを使います。たとえば、次のようにします。 
.LP
.ft 3
.nf
keytool \-selfcert \-alias dukeNew \-keypass b92kqmp
-dname "cn=Duke Smith, ou=Purchasing, o=BlueSoft, c=US"
.fi
.ft 1
.LP
生成された証明書は、指定した別名 (この例では \f3dukeNew\f1) によって
特定されるキーストアエントリに、要素を 1 つだけ持つ証明連鎖として格納され
ます。該当するキーストアエントリの既存の証明連鎖は、新しい証明連鎖によって
置き換えられます。 
.LP
.SH コマンドとオプションに関する注意事項
.LP
以下では、サブコマンドとそのオプションについて説明します。コマンドとオプションを指定するときは、次の点に注意してください。 
.TP 2
\(bu
どのコマンド名およびオプション名にも先頭にマイナス記号 (-) が付く
.TP 2
\(bu
各コマンドのオプションは任意の順序で指定できる
.LP
.TP 2
\(bu
イタリック体になっていないすべての項目、または中括弧か角括弧で
囲まれているすべての項目は、そのとおりに指定する必要がある
.TP 2
\(bu
オプションを囲む中括弧は、一般に、そのオプションをコマンド行で指定
しなかった場合に、既定値が使われることを意味する。中括弧は、
.BR -v
、
.BR -rfc
、および 
.B -J
オプションを囲むのにも使われるが、これらのオプションはコマンド行で指定
された場合にのみ意味を持つ (つまり、これらのオプションには、オプション
自体を指定しないこと以外に「既定値」は存在しない)
.TP 2
\(bu
オプションを囲む角括弧は、そのオプションをコマンド行で指定しなかった
場合に、値の入力を求められることを意味する。ただし、
.B -keypass
オプションをコマンド行で指定しなかった場合は、
.B keytool
がキーストアのパスワードから非公開鍵の復元を試みる。ユーザは、この試みが
失敗した場合に非公開鍵の入力を求められる
.TP 2
\(bu
イタリック体の項目の実際の値 (オプションの値) は、ユーザが指定する必要
がある。たとえば、
.B -printcert
サブコマンドの形式は次のとおりである 
.LP
.ft 3
.nf
keytool \-printcert {\-file cert_file} {\-v}
.fi
.ft 1
.LP
.B -printcert
サブコマンドを指定するときは、
.I cert_file 
の代わりに実際のファイル名を指定する。次に例を示す 
.LP
.ft 3
.nf
keytool \-printcert \-file VScert.cer
.fi
.ft 1
.LP
.TP 2
\(bu
オプションの値に空白 (スペース) が含まれている場合は、値を引用符で
囲む必要がある
.LP
.TP 2
\(bu
.B -help
サブコマンドはデフォルトのコマンドである。たとえば、次のようにコマンド行を
指定したとする 
.LP
.ft 3
.nf
keytool
.fi
.ft 1
.LP
これは、次のように指定することと同じである 
.LP
.ft 3
.nf
keytool \-help
.fi
.ft 1
.LP
.SS "オプションの既定値"
.IX "keytool" "Option Defaults" "\fLkeytool\fP \(em key and certificate management tool"
.LP
オプションの既定値は、次のとおりです。 
.LP
.ft 3
.nf
-alias "mykey"
-keyalg "DSA"
-keysize 1024
-validity 90
-keystore ユーザのホームディレクトリの .keystore というファイル
-file 読み込みの場合は標準入力、書き込みの場合は標準出力
.fi
.ft 1
.LP
署名アルゴリズム (
.B -sigalg
オプション) は、基になる非公開鍵のアルゴリズムから派生します。基になる
非公開鍵のタイプが DSA であり、
.B -sigalg
非公開鍵のタイプが RSA である場合、
.B -sigalg
は既定値で MD5withRSA になります。
.LP
.SS "ほとんどのサブコマンドで使われるオプション"
.IX "keytool" "Options that Appear for Most Subcommands" "\fLkeytool\fP \(em key and certificate management tool"
.LP
.B -v
オプションは、
.BR -help
を除くすべてのサブコマンドで使用できます。このオプションを指定した場合、コマンドは「冗長」モードで実行され、詳細な証明書情報が出力されます。 
.LP
また、
.BI  -J javaoption
オプションも、任意のサブコマンドで使用できます。このオプションを指定した場合、指定された 
.I -javaoption
文字列が Java インタプリタに直接渡されます。
.B keytool
は、実際には Java インタプリタに対する「ラッパー」です。このオプションには、空白を含めることはできません。このオプションは、実行環境またはメモリ使用を調整する場合に便利です。指定できるインタプリタオプションを一覧表示するには、コマンド行で 
.B java -h 
または 
.B java -X
と入力してください。 
.ft 3
.LP
これらのオプションは、キーストアに対する操作を行うすべてのコマンドで指
定できます。 
.TP
.BI  -storetype " storetype"
この修飾子は、インスタンスを生成するキーストアのタイプを指定します。デフォ
ルトのキーストアタイプは、セキュリティプロパティファイル内の keystore.type プ
ロパティの値で指定されたタイプです。この値は、
.BR java.security.KeyStore
の static 
.B getDefaultType
メソッドで取得できます。 
.TP
.BI -keystore " keystore"
キーストア (データベースファイル) の場所を指定します。デフォルトは、ユーザ
のホームディレクトリ内のファイル 
.B .keystore
です。ユーザのホームディレクトリは、
.B user.home
システムプロパティによって決まります。
.TP
.BI -storepass " storepass"
キーストアの完全性を保護するために使うパスワードを指定します。 
.LP
.I storepass
は、6 文字以上でなければなりません。指定したパスワードは、キーストアの内
容にアクセスするすべてのサブコマンドで使われます。この種のサブコマンドを実行する
ときに、コマンド行で
-storepass
オプションを指定しなかった場合は、パスワードの入力を求められます。 
.LP
キーストアから情報を取得する場合、
パスワードの指定は任意です。
パスワードを指定しない場合、取得した情報の
整合性をチェックすることはできないため、
警告が表示されます。
.LP
パスワードの扱いには十分注意する必要があります。「パスワードに関する注意事項」を参照してください。
.TP
.BI \-provider " provider_class_name"
サービスプロバイダがセキュリティプロパティファイルのリストに入っていないときに、
暗号化サービスプロバイダのマスタークラスファイルの名前を指定します。
.SS "パスワードに関する注意事項"
.IX "keytool" "Warning Regarding Passwords" "\fLkeytool\fP \(em key and certificate management tool"
.LP
キーストアに対する操作を行うほとんどのコマンドでは、ストアのパスワードが
必要です。また、一部のコマンドでは、非公開鍵のパスワードが必要になる
ことがあります。 
.LP
パスワードはコマンド行で指定できます (ストアのパスワードには 
.B -storepass 
オプション、非公開鍵のパスワードには
.B -keypass
オプションを使用)。ただし、テストを目的とする場合、または安全であることが
わかっているシステムで実行する場合以外は、コマンド行やスクリプトでパスワ
ードを指定しないでください。 
.LP
必要なパスワードのオプションをコマンド行で指定しなかった場合は、
パスワードの入力を求められます。password プロンプトでパスワードを入力
すると、入力したパスワードがエコーされ、そのまま画面に表示されます。こ
のため、周囲にほかのユーザがいる場合は、パスワードを見られないように
注意してください。 
.LP
.SS "コマンド"
.IX "keytool" "SUBCOMMANDS" "\fLkeytool\fP \(em key and certificate management tool"
「コマンドとオプションに関する注意事項」を参照してください。
.LP
.SS "キーストアへのデータの追加"
.IX "keytool" "Adding Data to the Keystore" "\fLkeytool\fP \(em key and certificate management tool"
.TP
\f3\-genkey {\-alias \f2alias\f3} {\-keyalg \f2keyalg\f3} {\-keysize \f2keysize}
.ti +5n
\f3{\-sigalg \f2sigalg\f3} [\-dname \f2dname\f3] [\-keypass \f2keypass\f3] 
.if n .ti +5n
\f3{\-validity \f2valDays\f3} 
.if t .ti +5n
{\-storetype \f2storetype\f3} 
.if n .ti +5n
\f3{\-keystore \f2keystore\f3} [\-storepass \f2storepass\f3]
.ti +5n
.BI [\-provider " provider_class_name" ]
.B {\-v}
.if n .ti +5n
\f3{\-J\f2javaoption\f3}
.RS
.LP
鍵のペア (公開鍵および関連する非公開鍵) を生成します。公開鍵は 
X.509 v1 自己署名証明書でラップされます。証明書は、単一の要素を持つ
証明連鎖として格納されます。この証明連鎖と非公開鍵は、
.IR alias
で特定される新しいキーストアエントリに格納されます。 
.LP
keyalg には、鍵のペアを生成するのに使うアルゴリズムを指定し、
.I keysize 
には、生成する各鍵のサイズを指定します。
.I sigalg
には、自己署名証明書に署名を付けるときに使うアルゴリズムを指定します。
このアルゴリズムは、keyalg と互換性のあるものでなければなりません。「サポー
トされるアルゴリズムと鍵のサイズ」を参照してください。 
.LP
.I dname
には、
.IR alias
に関連付け、自己署名証明書の issuer フィールドと subject フィールドとして
使う X.500 識別名を指定します。コマンド行で識別名を指定しなかった場合は
、識別名の入力を求められます。 
.LP
.I keypass
には、生成される鍵のペアのうち、非公開鍵を保護するのに使うパスワードを
指定します。パスワードを指定しなかった場合は、パスワードの入力を求められ
ます。このとき、Enter キーを押すと、キーストアのパスワードと同じパスワードが
鍵のパスワードに設定されます。
.I keypass
は、6 文字以上でなければなりません。パスワードの扱いには十分注意する
必要があります。「
.BR パスワードに関する注意事項
」を参照してください。
.LP
.I valDays
には、証明書の有効日数を指定します。
.RE
.TP
\f3\-import {\-alias \f2alias\f3} {\-file \f2cert_file\f3} [\-keypass \f2keypass\f3] 
.ti +5n
\f3{\-noprompt} {\-trustcacerts} {\-storetype \f2storetype\f3} 
.if n .ti +5n
\f3{\-keystore \f2keystore\f3}
.if t .ti +5n
[\-storepass \f2storepass\f3]
.if n .ti +5n
.BI [\-provider " provider_class_name" ]
.if n .ti +5n
.BI "{\-v} {\-J" javaoption }
.RS
.LP
ファイル 
.IR cert_file
から証明書または証明連鎖 (証明連鎖の場合は、PKCS#7 形式の応答で提供されるもの) を読み込み、
.IR alias
によって特定されるキーストアエントリに格納します。証明書または PKCS#7 応答を標準入力から
読み込みます。 
.LP
.B keytool
では、X.509 v1、v2、v3 の証明書、および、PKCS#7 形式の証明書から構成
されている PKCS#7 形式の証明連鎖をインポートできます。インポートするデー
タは、バイナリエンコーディング方式、またはプリント可能エンコーディング方式
(Base64 エンコーディングとも呼ばれる) のどちらかで提供する必要があります。
プリント可能エンコーディング方式は、インターネット RFC 1421 証明書エンコー
ディング規格で定義されています。このエンコーディング方式の場合、証明書は
「-----BEGIN」で始まる文字列で開始され、「-----END」で始まる文字列で終了しなければなりません。 
.LP
証明書は、次の 2 つの理由でインポートします。
.LP
1. 信頼できる証明書のリストに追加する
.LP
2. 証明書署名要求 (
.B \-certreq 
コマンドを参照) を 
CA に送信した結果として、
その CA から受け取った
証明書応答をインポートする
.SH 信頼できる新規証明書のインポート
新しく信頼できる証明書をインポートする場合、キーストアに
.I alias
が存在していてはいけません。
.B keytool
は、キーストアに証明書を追加する前に、キーストア内にすでに存在する信頼
できる証明書を使って、インポートする証明書から (ルート CA の) 自己署名証
明書に至るまでの信頼の連鎖の構築を試みます。 
.LP
.B -trustcacerts
オプションが指定されている場合は、信頼の連鎖を構築するときに、ほかの
証明書も考慮されます。考慮の対象となる証明書は、
.BR cacerts . 
.LP

.B keytool 
が、インポートする証明書から
自己署名証明書までの
信頼できるパスの確立に
失敗した場合 (キーストアまたは
「cacerts」ファイルから)、
証明書情報を出力し、
ユーザに確認を求めます。
たとえば、
この場合は、表示された証明書のフィンガープリントと、
ほかのなんらかの (信頼できる) 情報源 (証明書の所有者自身など) 
から入手したフィンガープリントとを比較します。「信頼できる証明書」
として証明書をインポートする前に、証明書が有効であることを
必ず確認してください。「信頼できる証明書のインポートに関する注意事項」
を参照してください。インポート操作は、
この時点で中止できます。
.B \-noprompt 
オプションが指定されている場合、
ユーザとの対話は行われません。
.SH 証明書応答のインポート
証明書応答をインポートするときは、キーストア内の信頼できる証明書、
および (
.B -trustcacerts
オプションが指定されている場合は) 
.B cacerts
キーストアファイルで構成された証明書を使って証明書応答が検査されます。 
.LP
証明書応答が信頼できるかどうかを決定する方法は、
次のとおりです。
.LP
証明書応答が単一の X.509 証明書である場合、
.B keytool
は、証明書応答から (ルート CA の) 自己署名証明書に至るまでの信頼連鎖の
確立を試みます。証明書応答と、証明書応答の認証に使われる証明書の階層
構造は、
.IR alias 
の新しい証明書連鎖を形成します。 
.LP
証明書応答が PKCS#7 形式の証明連鎖である場合、
.B keytool
は、まず連鎖を並べ替えて、ユーザの証明書が最初に、ルート CA の自己署名証明書が最後にくるようにしたあと、証明書応答に含まれるルート CA の証明書と、キーストア内または (
.B -trustcacerts
オプションが指定されている場合は) 
.B cacerts
キーストアファイル内の信頼できる証明書とをすべて比較し、一致するものが
あるかどうかを調べます。一致するものが見つからなかった場合は、ルート CA 
の証明書の情報を表示し、ユーザに確認を求めます。この場合は、表示された
証明書のフィンガープリントと、ほかのなんらかの (信頼できる) 情報源 (ルート 
CA 自身など) から入手したフィンガープリントとを比較します。インポート操作は、
証明書を確認する時点で中止できます。ただし、-noprompt オプションが指定さ
れている場合、ユーザとの対話は行われません。 
.LP
.I alias 
に関連付けられた以前の証明連鎖は、新しい証明連鎖によって置き換えられ
ます。以前の証明連鎖を新しい証明連鎖で置き換えることができるのは、有効
な keypass、つまり該当するエントリの非公開鍵を保護するためのパスワードを
指定した場合だけです。パスワードを指定しておらず、非公開鍵のパスワード
がキーストアのパスワードと異なる場合は、非公開鍵のパスワードの入力を求め
られます。パスワードの扱いには十分注意する必要があります。「
.BR パスワードに関する注意事項
」を参照してください。 
.RE
.TP
\f3\-selfcert {\-alias \f2alias\f3} {\-sigalg \f2sigalg\f3} {\-dname \f2dname\f3}
.ti +5n
\f3{\-validity \f2valDays\f3}
[\-keypass \f2keypass\f3] 
.if n .ti +5n
\f3{\-storetype \f2storetype\f3}
.if t .ti +5n
{\-keystore \f2keystore\f3}
.if n .ti +5n
\f3[\-storepass \f2storepass\f3]
.if n .ti +5n
.BI [\-provider " provider_class_name" ]
.ti +5n
\f3{\-v} {\-J\f2javaoption\f3}
.RS
.LP
.IR alias
に関連付けられた非公開鍵と公開鍵を含むキーストアの情報を使って、
X.509 v1 自己署名証明書を生成します。コマンド行で 
.I dname
が指定されている場合は、証明書の issuer フィールドと subject フィールドの
両方に対して、
.I dname
が X.500 識別名として使われます。
.I dname
が指定されていない場合は、(既存の証明連鎖の最後の)
.I alias
に関連付けられた X.500 識別名が使われます。 
.LP
生成された証明書は、単一の要素を持つ証明連鎖として、
.IR alias
で特定されるキーストアエントリに格納されます。該当するエントリの既存の
証明連鎖は、新しい証明連鎖によって置き換えられます。 
.LP
.I sigalg
には、証明書に署名を付けるときに使うアルゴリズムを指定します。「サポートされるアルゴリズムと鍵のサイズ」を参照してください。 
.LP
非公開鍵はキーストア内ではパスワードによって保護されているので、非公開
鍵にアクセスするには、適切なパスワードを提供する必要があります。コマンド行で 
.I keypass
を指定しておらず、非公開鍵のパスワードがキーストアのパスワードと異なる場
合は、非公開鍵のパスワードの入力を求められます。パスワードの扱いには十
分注意する必要があります。「
.BR パスワードに関する注意事項
」を参照してください。 
.LP
.I valDays 
には、証明書の有効日数を指定します。
.RE
.SH cacerts 証明書ファイル
「cacerts」という証明書ファイルが、セキュリティプロパティ
ディレクトリ、java.home/lib/security にあります。java.home は
実行環境のディレクトリ (JDK の jre ディレクトリまたは Java
Runtime Environment のトップレベルディレクトリ) です。
.LP
「cacerts」ファイルは、CA 証明書が格納されたシステム全体の
キーストアを表します。システム管理者は 
.B keytool 
でキーストアの
タイプとして「jks」を指定して、そのファイルを設定および管理で
きます。「cacerts」キーストアファイルは、次の別名と X.500 所有者
識別名のルート CA 証明書を含んだ状態で出荷されます。
.LP
.RS 5
別名: thawtepersonalfreemailca 
所有者 DN:
EmailAddress=personal-freemail@thawte.com, 
CN=Thawte Personal Freemail CA, 
OU=Certification Services Division, 
O=Thawte Consulting, L=Cape Town, ST=Western Cape,
C=ZA 
.LP
別名: thawtepersonalbasicca 
所有者 DN: EmailAddress=personal-basic@thawte.com, 
CN=Thawte Personal Basic CA, 
OU=Certification Services Division, 
O=Thawte Consulting, L=Cape Town, ST=Western Cape,
C=ZA 
.LP
別名: thawtepersonalpremiumca 
所有者 DN:
EmailAddress=personal-premium@thawte.com, 
CN=Thawte Personal Premium CA, 
OU=Certification Services Division, 
O=Thawte Consulting, L=Cape Town, ST=Western Cape,
C=ZA 
.LP
別名: thawteserverca 
所有者 DN: EmailAddress=server-certs@thawte.com, 
CN=Thawte Server CA, 
OU=Certification Services Division,
O=Thawte Consulting cc, L=Cape Town, ST=Western
Cape, C=ZA 
.LP
別名: thawtepremiumserverca 
所有者 DN: EmailAddress=premium-server@thawte.com,
CN=Thawte Premium Server CA, 
OU=Certification Services Division, 
O=Thawte Consulting cc, L=Cape Town, ST=Western
Cape, C=ZA 
.LP
別名: verisignclass1ca 
所有者 DN: OU=Class 1 Public Primary Certification
Authority, 
O="VeriSign, Inc.", C=US 
.LP
別名: verisignclass2ca
所有者 DN: OU=Class 2 Public Primary Certification
Authority, 
O="VeriSign, Inc.", C=US 
.LP
別名: verisignclass3ca 
所有者 DN: OU=Class 3 Public Primary Certification
Authority, 
O="VeriSign, Inc.", C=US 
.LP
別名: verisignclass4ca 
所有者 DN: OU=Class 4 Public Primary Certification
Authority, 
O="VeriSign, Inc.", C=US 
.LP
別名: verisignserverca 
所有者 DN: OU=Secure Server Certification Authority, 
O="RSA Data Security, Inc.", C=US 
.LP
別名: baltimorecodesigningca 
所有者 DN: CN=Baltimore CyberTrust Code Signing Root, 
OU=CyberTrust, O=Baltimore, C=IE 
.LP
別名: gtecybertrustca 
所有者 DN: CN=GTE CyberTrust Root, 
O=GTE Corporation, C=US 
.LP
別名: gtecybertrust5ca 
所有者 DN: CN=GTE CyberTrust Root 5, 
OU="GTE CyberTrust Solutions, Inc.", O=GTE Corporation,
C=US 
.RE
.LP
「cacerts」キーストア ファイルの初期パスワードは「changeit」です。
システム管理者は、JDK のインストール時にそのパスワードと
そのファイルの既定値のアクセス権を変更する必要があります。 
.LP
重要: cacerts ファイルの確認 
cacerts ファイルの CA は、ほかのエンティティに
対して証明書を署名および発行するためのエンティティ
として信頼するため、cacerts ファイルは慎重に管理して
ください。cacerts ファイルには、信頼する CA 以外の
証明書を含めないでください。cacerts ファイルに
バンドルされている信頼できるルート CA 証明書を確認して、
信頼できるかどうかを独自に決定する必要があります。
信頼できない CA 証明書を cacerts ファイルから
削除するには、
.B keytool 
コマンドの delete オプションを
使用します。cacerts ファイルは、JRE インストール 
ディレクトリにあります。
このファイルを編集する権限がない場合は、
システム管理者に問い合わせてください。 
.TP
\f3\-selfcert {\-alias \f2alias\f3} {\-sigalg \f2sigalg\f3} {\-dname \f2dname\f3}
.ti +5n
\f3{\-validity \f2valDays\f3}
[\-keypass \f2keypass\f3]
.if n .ti +5n
\f3{\-storetype \f2storetype\f3}
.if t .ti +5n
{\-keystore \f2keystore\f3}
.if n .ti +5n
\f3[\-storepass \f2storepass\f3]
.if n .ti +5n
.BI [\-provider " provider_class_name" ]
.ti +5n
\f3{\-v} {\-J\f2javaoption\f3}
.RS
.LP
.IR alias
に関連付けられた非公開鍵および公開鍵を含むキー
ストアの情報を使って、X.509 v1 自己署名証明書を
作成します。コマンド行で
.I dname
が指定されている場合は、証明書 issuer フィールドと
subject フィールドの両方に対して、
.I dname
が X.500 識別名として使われます。
.I dname
が指定されていない場合は、(既存の証明連鎖の最後の)
.I alias
に関連付けられた X.500 識別名が使われます。 
.LP
生成された証明書は、単一の要素を持つ証明連鎖として、
.IR alias
で特定されるキーストアエントリに格納されます。
該当するエントリの既存の証明連鎖は、新しい証明連鎖
によって置き換えられます。 
.LP
.I sigalg
には、証明書に署名を付けるときに使うアルゴリズムを
指定します。「サポートされるアルゴリズムと鍵のサイズ」
を参照してください。
.LP
非公開鍵はキーストア内ではパスワードによって保護されているので、
非公開鍵にアクセスするには、適切なパスワードを提供する必要が
あります。コマンド行で
.I keypass
を指定しておらず、非公開鍵のパスワードがキーストアのパスワードと
異なる場合は、非公開鍵のパスワードの入力を求められます。
パスワードの扱いには十分注意する必要があります。「
.BR パスワードに関する注意事項
」を参照してください。
.LP
.I valDays
には、証明書の有効日数を指定します。
.RE
.ne 2
.br
.TP
.if t \f3\-identitydb {\-file \f2idb_file\f3} {\-storetype \f2storetype\f3} \f3{\-keystore \f2keystore\f3}
.if n \f3\-identitydb {\-file \f2idb_file\f3} {\-storetype \f2storetype\f3}
.ti +5n
.if n \f3{\-keystore \f2keystore\f3}
\f3[\-storepass \f2storepass\f3] 
.if n .ti +5n
.BI [\-provider " provider_class_name" ]
.if n .ti +5n
\f3{\-v} {\-J\f2javaoption\f3}
.RS
.LP
ファイル
.IR idb_file
から JDK 1.1.x 形式のアイデンティティデータベースを読み込み、
アイデンティティデータベースのエントリをキーストアに追加します。ファイルが
指定されていない場合は、標準入力からアイデンティティデータベースを読み
込みます。キーストアが存在しない場合は、作成されます。 
.LP
アイデンティティデータベースのエントリ (「アイデンティティ」) のうち、キーストア
にインポートされるのは、信頼できるものとしてマークされたエントリだけです。そ
の他のすべてのエントリは無視されます。信頼できるアイデンティティごとに、キ
ーストアエントリが 1 つ作成されます。アイデンティティの名前は、キーストアエン
トリの「別名」として使われます。 
.LP
信頼できるアイデンティティからのすべての非公開鍵は、どれも同じパスワード 
storepass で暗号化されます。このパスワードは、キーストアの完全性を保護する
ために使われるパスワードと同じです。
.B keytool
の 
.B -keypasswd
コマンドのオプシ
ョンを使えば、あとで個別に非公開鍵にパスワードを割り当てることができます。 
.LP
アイデンティティデータベース内のアイデンティティは、それぞれが同じ公開鍵
を認証する複数の証明書を含んでいることがあります。一方、非公開鍵を格納
するキーストアの鍵エントリに含まれるのは、その非公開鍵と、単一の「証明連鎖
」(最初は単一の証明書だけ) であり、非公開鍵に対応する公開鍵は連鎖内の最
初の証明書に含まれています。アイデンティティから情報をインポートする場合は
、アイデンティティの最初の証明書だけがキーストアに格納されます。これは、ア
イデンティティデータベース内のアイデンティティの名前が、対応するキーストア
エントリの別名として使われ、別名はキーストア内で一意であるためです。 
.RE
.SS "データのエクスポート"
.IX "keytool" "Exporting Data" "\fLkeytool\fP \(em key and certificate management tool"
.TP
.if t \f3\-certreq {\-alias \f2alias\f3} {\-sigalg \f2sigalg\f3} \f3{\-file \f2certreq_file\f3} [\-keypass \f2keypass\f3] 
.if n \f3\-certreq {\-alias \f2alias\f3} {\-sigalg \f2sigalg\f3} \f3{\-file \f2certreq_file\f3}
.if n .ti +5n
.if n \f3[\-keypass \f2keypass\f3] 
.ti +5n
\f3{\-storetype \f2storetype\f3} {\-keystore \f2keystore\f3} 
.if n .ti +5n
\f3[\-storepass \f2storepass\f3]
.ti +5n
.BI [\-provider " provider_class_name" ]
.if n .ti +5n
\f3{\-v} {\-J\f2javaoption\f3}
.RS
.LP
PKCS#10 形式を使って証明書署名要求 (CSR) を生成します。 
.LP
CSR は、証明書発行局 (CA) に送信することを目的としたものです。CA 
は、証明書要求者を (通常はオフラインで) 認証し、証明書または証明連
鎖を送り返します。この証明書または証明連鎖は、キーストア内の既存の証
明連鎖 (最初は 1 つの自己署名証明書から構成される) に置き換えて使い
ます。 
.LP
.I alias 
に関連付けられた非公開鍵と X.500 識別名は、PKCS#10 証明書要求を作成
するのに使われます。非公開鍵はキーストア内ではパスワードによって保護され
ているので、非公開鍵にアクセスするには、適切なパスワードを提供する必要が
あります。コマンド行で 
.I alias 
を指定しておらず、非公開鍵のパスワードがキーストアのパスワードと異なる場合
は、非公開鍵のパスワードの入力を求められます。
.LP
パスワードの扱いには十分注意する必要があります。「
.BR パスワードに関する注意事項
」を参照してください。 
.LP
.I sigalg 
には、CSR に署名を付けるときに使うアルゴリズムを指定します。「サポートさ
れるアルゴリズムと鍵のサイズ」を参照してください。 
.LP
CSR は、ファイル 
.IR certreq_file
に格納されます。ファイルが指定されていない場合は、標準出力に CSR が出力されます。 
.LP
CA からの応答をインポートするには、import コマンドを使います。
.RE
.TP
.if t \f3\-export {\-alias \f2alias\f3} {\-file \f2cert_file\f3} \f3{\-storetype \f2storetype\f3} {\-keystore \f2keystore\f3} 
.if n \f3\-export {\-alias \f2alias\f3} {\-file \f2cert_file\f3} \f3{\-storetype \f2storetype\f3}
.if n .ti +5n
.if n \f3{\-keystore \f2keystore\f3} 
.if t .ti +5n
\f3[\-storepass \f2storepass\f3]
.if n .ti +5n
.BI [\-provider " provider_class_name" ]
.ti +5n
\f3{\-rfc} {\-v} {\-J\f2javaoption\f3}
.RS
.LP
.IR alias
に関連付けられた証明書を (キーストアから) 読み込み、ファイル
.IR cert_file
に格納します。 
.LP
ファイルが指定されていない場合は、
.B 標準出力
に証明書が出力されます。 
.LP
デフォルトでは、バイナリエンコーディングの証明書が出力されます。ただし、
.B -rfc
オプションを指定した場合は、プリント可能エンコーディング方式の証明書が
出力されます。プリント可能エンコーディング方式は、インターネット RFC 1421 
証明書エンコーディング規格で定義されています。 
.LP
.I alias
が、信頼できる証明書を参照している場合は、該当する証明書が出力されます。
それ以外の場合、
.I alias
は、関連付けられた証明連鎖を持つ鍵エントリを参照します。この場合は、連鎖
内の最初の証明書が返されます。この証明書は、
.I alias
によって表されるエンティティの公開鍵を認証する証明書です。
.LP
.SS "データの表示"
.IX "keytool" "Displaying Data" "\fLkeytool\fP \(em key and certificate management tool"
.TP
.if t \f3\-list {\-alias \f2alias\f3} {\-storetype \f2storetype\f3} {\-keystore \f2keystore}\f3 [\-storepass \f2storepass\f3] 
.if n \f3\-list {\-alias \f2alias\f3} {\-storetype \f2storetype\f3} \f3{\-keystore \f2keystore}
.ti +5n
.if n [\-storepass \f2storepass\f3] 
.if n .ti +5n
.BI [\-provider " provider_class_name" ]
.if n .ti +5n
\f3{\-v | \-rfc} {\-J\f2javaoption\f3}
.RS
.LP
.IR alias
で特定されるキーストアエントリの内容を (標準出力に) 出力します。別名が指定さ
れていない場合は、キーストア全体の内容が表示されます。 
.LP
このコマンドは、デフォルトでは証明書の MD5 フィンガープリントを表示しま
す。
.B -v
オプションが指定されている場合は、所有者、発行者、シリアル番号などの付加
的な情報とともに、人間が読むことのできる形式で証明書が表示されます。
.B \-rfc
オプションが指定されている場合は、プリント可能なエンコーディング方式で証明
書の内容が表示されます。プリント可能エンコーディング方式は、インターネット 
RFC 1421 証明書エンコーディング規格で定義されています。 
.LP
.B -v
オプションと 
.BR -rfc 
オプションとを同時に指定することはできません。 
.RE
.TP
\f3-printcert {-file \f2cert_file\f3} {-v} {-J\f2javaoption\f3}
.RS
.LP
ファイル
.IR cert_file
から証明書を読み込み、人間が読むことのできる形式で証明書の内容を
表示します。ファイルが指定されていない場合は、標準入力から証明書を
読み込みます。 
.LP
証明書は、バイナリエンコーディングまたはプリント可能エンコーディング
方式で表示できます。プリント可能エンコーディング方式は、インターネット 
RFC 1421 証明書エンコーディング規格で定義されています。 
.LP
注: このコマンドはキーストアとは関係なく動作します。
.RE
.SS "キーストアの管理"
.IX "keytool" "Managing the Keystore" "\fLkeytool\fP \(em key and certificate management tool"
.TP
.if t \f3\-keyclone {\-alias \f2alias\f3} [\-dest \f2dest_alias\f3] [\-keypass \f2keypass\f3] {\-new \f2new_keypass\f3} 
.if n \f3\-keyclone {\-alias \f2alias\f3} [\-dest \f2dest_alias\f3] [\-keypass \f2keypass\f3]
.if n .ti +5n
.if n {\-new \f2new_keypass\f3} 
.if t .ti +5n
\f3{\-storetype \f2storetype\f3}
.if n .ti +5n
{\-keystore \f2keystore\f3} 
\f3[\-storepass \f2storepass\f3]
.ti +5n
.BI [\-provider " provider_class_name" ]
.if n .ti +5n
\f3{\-v} {\-J\f2javaoption\f3}
.RS
.LP
元のエントリと同じ非公開鍵と認証連鎖を持つ、新しいキーストアエントリを
作成します。 
.LP
.I alias
には、元のエントリを指定します。alias を指定しなかった場合は、既定値の 
mykey が使われます。
.IR dest_alias
には、新しい (複製先の) エントリを指定します。コマンド行で複製先の別名を
指定しなかった場合は、別名の入力を求められます。 
.LP
非公開鍵のパスワードがキーストアのパスワードと異なる場合は、有効な 
.I keypass
が指定された場合にのみ、エントリが複製されます。このとき指定するのは、
.IR alias
に関連付けられた非公開鍵を保護するためのパスワードです。
コマンド行でこのパスワードが指定されず、非公開鍵の
パスワードがキーストアのパスワードと異なる場合は、パスワードの入力を求め
られます。 複製されたエントリの非公開鍵は、必要に応じて別のパスワードで
保護できます。コマンド行で 
.B -new
オプションを指定しなかった場合は、新しいエントリのパスワードの入力を求め
られます。このとき、複製された非公開鍵に対して同じパスワードを指定できます。 
.LP
パスワードの扱いには十分注意する必要があります。「
.BR パスワードに関する注意事項
」を参照してください。 
.LP
このコマンドは、ある与えられた鍵のペアに対応する複数の認証連鎖を確立
するために使用できます。また、バックアップを目的として使用することもできます。
.RE
.TP
\f3\-storepasswd {\-new \f2new_storepass\f3} {\-storetype \f2storetype\f3}
.ti +5n
\f3{\-keystore \f2keystore\f3} [\-storepass \f2storepass\f3]
.if n .ti +5n
.BI [\-provider " provider_class_name" ]
.ti +5n
\f3{\-v} {\-J\f2javaoption\f3}
.RS
.LP
キーストアの内容の完全性を保護するために使うパスワードを変更します。
.IR new_storepass
には、新しいパスワードを指定します。
.IR new_storepass
は、6 文字以上でなければなりません。
.LP
パスワードの扱いには十分注意する必要があります。
「
.BR パスワードに関する注意事項
」を参照してください。
.RE
.TP
\f3\-keypasswd {\-alias \f2alias\f3} [\-keypass \f2old_keypass\f3] 
.ti +5n
\f3[\-new \f2new_keypass\f3] {\-storetype \f2storetype\f3} 
.if n .ti +5n
\f3{\-keystore \f2keystore\f3}
.if t .ti +5n
[\-storepass \f2storepass\f3] 
.if n .ti +5n
.BI [\-provider " provider_class_name" ]
.if n .ti +5n
\f3{\-v} {\-J\f2javaoption\f3}
.RS
.LP
.I alias
によって特定される非公開鍵を保護するためのパスワードを、
.I old_keypass
から 
.IR new_keypass
に変更します。 
.LP
コマンド行で 
.B -keypass 
オプションを指定しておらず、非公開鍵のパスワードがキーストアのパスワードと
異なる場合は、非公開鍵のパスワードの入力を求められます。 
.LP
コマンド行で
.B -new
オプションを指定しなかった場合は、新しいパスワードの入力を求められます。
.LP
パスワードの扱いには十分注意する必要があります。「
.BR パスワードに関する注意事項
」を参照してください。
.RE
.TP
\f3\-delete [\-alias \f2alias\f3] {\-storetype \f2storetype\f3} 
.ti +5n
\f3{\-keystore \f2keystore\f3} [\-storepass \f2storepass\f3]
.if n .ti +5n
.BI [\-provider " provider_class_name" ]
.ti +5n
\f3{\-v} \f3{\-J\f2javaoption\f3}
.RS
.LP
.IR alias
によって特定されるエントリをキーストアから削除します。コマンド行で別名を指定しなかった場合は、別名の入力を求められます。
.RE
.SS "ヘルプの表示"
.IX "keytool" "Getting Help" "\fLkeytool\fP \(em key and certificate management tool"
.TP
.B -help
.LP
すべてのコマンドとそのオプションを一覧表示します。
.SH "使用例"
.LP
ここでは、自分の鍵のペアおよび信頼できるエンティティからの証明書を管理
するためのキーストアを作成する場合を例として示します。 
.LP
.SS "鍵のペアの生成"
.IX "keytool" "Generating Your Key Pair" "\fLkeytool\fP \(em key and certificate management tool"
.LP
まず、キーストアを作成して鍵のペアを生成する必要があります。次に示すのは、
実行するコマンドの例です。 
.LP
.ft 3
.nf
keytool \-genkey \-dname "cn=Mark Jones, ou=Java, o=Sun, c=US"
-alias business -keypass kpi135 -keystore /working/mykeystore
-storepass ab987c -validity 180
.fi
.ft 1
.LP
注: 上のコマンド例は、読みやすくするために複数の行に分けてありますが、
実際には 1 行で指定する必要があります。 
.LP
この例では、
.B working
ディレクトリに 
.B mykeystore
という名前のキーストアを作成し (キーストアはまだ存在していないと仮定する)、
作成したキーストアにパスワード
.BR ab987c
を割り当てます。生成する公開鍵と非公開鍵のペアに対応するエンティティの
「識別名」は、通称が 
.BR Mark Jones
、組織単位が
.BR Java
、組織が
.B Sun
、2 文字の国番号が
.BR US
です。公開鍵と非公開鍵のサイズはどちらも 1024 ビットで、鍵の作成にはデ
フォルトの DSA 鍵生成アルゴリズムを使用します。 
.LP
このコマンドは、公開鍵と識別名情報を含む自己署名証明書 (デフォルトの 
SHA1withDSA 署名アルゴリズムを使用) を作成します。証明書の有効期間は 
.B 180
日です。証明書は、別名
.BR business 
で特定されるキーストアエントリ内の非公開鍵に関連付けられます。非公開鍵
にはパスワード 
.BR kpi135 
が割り当てられます。 
.LP
オプションの既定値を使う場合は、上に示したコマンドを大幅に短くすることが
できます。実際には、オプションを 1 つも指定せずにコマンドを実行することも
可能です。既定値を持つオプションでは、オプションを指定しなければ既定値
が使われ、必要な値については入力を求められます。たとえば、単に次のよう
に入力することもできます。 
.LP
.ft 3
.nf
keytool \-genkey
.fi
.ft 1
.LP
この場合は、
.B mykey
という別名でキーストアエントリが作成され、新しく生成された鍵のペア、および 
90 日間有効な証明書がこのエントリに格納されます。このエントリは、ホームディ
レクトリ内の
.B .keystore
という名前のキーストアに置かれます。このキーストアがまだ存在していない場合
は、作成されます。識別名情報、キーストアのパスワード、および非公開鍵のパ
スワードについては、入力を求められます。 
.LP
以下では、オプションを指定しないで 
.B -genkey
コマンドを実行したものとして例を示します。情報の入力を求められた場合は、
最初に示した
.B -genkey
コマンドの値を入力したものとします (たとえば、非公開鍵のパスワードには
.BR  kpi135
と指定)。 
.LP
.SS "証明書発行局に対する"
.SS "署名付き証明書の要求"
.IX "keytool" "Requesting a Signed Certificate from a Certification Authority" "\fLkeytool\fP \(em key and certificate management tool"
.LP
現時点で手元にあるのは、1 通の自己署名証明書だけです。証明書に証明書
発行局 (CA) の署名が付いていれば、ほかのユーザから証明書が信頼できる
可能性も高くなります。CA の署名を取得するには、まず、証明書署名要求 
(CSR) を生成します。たとえば、次のようにします。 
.LP
.ft 3
.nf
keytool \-certreq \-file MarkJ.csr
.fi
.ft 1
.LP
CSR (デフォルト別名 \f3mykey\f1 によって特定されるエンティティの CSR) が作成され、
.BR  MarkJ.csr
という名前のファイルに置かれます。このファイルは、VeriSign などの CA に
提出します。CA は要求者を (通常はオフラインで) 認証し、要求者の公開鍵
を認証した署名付きの証明書を送り返します。場合によっては、CA が証明書
の連鎖を返すこともあります。証明書の連鎖では、各証明書が連鎖内のその
前の署名者の公開鍵を認証します。 
.LP
.SS "CA からの証明書のインポート"
.IX "keytool" "Importing a Certificate for the CA" "\fLkeytool\fP \(em key and certificate management tool"
.LP
作成した自己署名証明書は、証明連鎖で置き換える必要があります。
証明連鎖では、各証明書が、「ルート」CA を起点とする連鎖内の次の証明書
の署名者の公開鍵を認証します。 
.LP
CA からの証明書応答をインポートするには、キーストアか、(
.B import
コマンドで説明しているように) cacerts キーストアファイル内に 1 つ以上の
「信頼できる証明書」を必要とします。 
.TP 2
\(bu
証明書応答が証明連鎖の場合は、連鎖のトップの証明書 
(その CA の公開鍵を認証する「ルート」CA の証明書) だけを必要とする
.TP 2
\(bu
証明書応答が単一の証明書の場合は、証明書に署名した CA の発行用の
証明書が必要で、その証明書が自己署名されない場合は、さらにその証明書
の署名者用の証明書を必要とする。このようにして自己署名される「ルート」CA 
の証明書までそれぞれ証明書を必要とする 
.LP
.B cacerts 
キーストアファイルは、5 つの VeriSign ルート CA 証明書を含んだ状態で
出荷されているので、VeriSign の証明書を、信頼できる証明書としてキーストア
内にインポートする必要はない可能性があります。ただし、ほかの CA に対して
署名付き証明書を要求していて、この CA の公開鍵を認証する証明書が、
.BR cacerts
にまだ追加されていない場合は、該当する CA からの証明書を、「信頼できる
証明書」としてインポートする必要があります。 
.LP
通常、CA からの証明書は、自己署名証明書、またはほかの CA によって署名
された証明書です (後者の場合は、該当するほかの CA の公開鍵を認証する
証明書も必要)。たとえば、ABC という企業が CA だとします。このとき、この CA 
の公開鍵を認証する自己署名証明書と考えられる 
.B ABCCA.cer
という名前のファイルを、ABC から入手したとします。 
.LP
「信頼できる証明書」として証明書をインポートする前に、証明書が有効であることを必ず確認してください。まず、証明書の内容を表示し (
.B -printcert
サブコマンド、または 
.B -noprompt
オプションなしで
.B -import 
サブコマンドを使用)、表示された証明書のフィンガープリントが、期待されるフィン
ガープリントと一致するかどうかを確認します。証明書を送信した人物に連絡し、
この人物が提示した (または安全な公開鍵のリポジトリによって提示される) フィ
ンガープリントと、上のコマンドで表示されたフィンガープリントとを比較します。
フィンガープリントが一致すれば、送信途中でほかの何者か (攻撃者など) によ
る証明書のすり替えが行われていないことを確認できます。送信途中でこの種の
攻撃が行われていた場合、チェックを行わずに証明書をインポートすると、攻撃
者によって署名されたすべてのものを信頼することになります。 
.LP
.BR  ABCCA.cer
を有効な証明書として信頼する場合は、証明書をキーストアに追加
できます。たとえば、次のようにします。 
.LP
.ft 3
.nf
keytool \-import \-alias abc \-file ABCCA.cer
.fi
.ft 1
.LP
.BR  ABCCA.cer
ファイルのデータを含む「信頼できる証明書」のエントリがキーストア内に作成され、該当するエントリに 
.B abc
という別名が割り当てられます。 
.LP
.SS "CA からの証明書"
.SS "応答のインポート"
.IX "keytool" "Importing the Certificate Reply from the CA" "\fLkeytool\fP \(em key and certificate management tool"
.LP
証明書署名要求の提出先の CA の公開鍵を認証する証明書をインポートした
あとは (または同種の証明書がすでに
.B cacerts
ファイル内に存在している場合は)、証明書応答をインポートし、自己署名証明
書を証明連鎖で置き換えることができます。この証明連鎖は、CA の応答が連
鎖の場合、証明書署名要求に対する応答として CA から送り返された証明連鎖
です。また、CA の応答が単一の証明書の場合は、この証明書応答と、インポート先の
キーストア内または 
.BR cacerts
キーストアファイル内にすでに存在する信頼できる証明書とを使って構築した証
明連鎖です。 
.LP
たとえば、証明書署名要求を VeriSign に送信したとします。送り返された証明書の名前が 
.BR VSMarkJ.cer
だとすると、次のようにして応答をインポートできます。 
.LP
.ft 3
.nf
keytool \-import \-trustcacerts \-file VSMarkJ.cer
.fi
.ft 1
.LP
.SS "公開鍵を認証する証明書の"
.SS "エクスポート"
.IX "keytool" "Exporting a Certificate Authenticating Your Public Key" "\fLkeytool\fP \(em key and certificate management tool"
.LP
たとえば、
.BR jarsigner (1)
ツールを使って Java ARchive (JAR) ファイルに署名を付けたとします。
この JAR ファイルはクライアントによって使われますが、クライアント側では
署名を認証したいと考えています。 
.LP
クライアントが署名を認証する方法の 1 つに、まず自分の公開鍵の証明書を
「信頼できる」エントリとしてクライアントのキーストアにインポートする方法がありま
す。そのためには、証明書をエクスポートして、クライアントに提供します。たとえ
ば、次のようにして、証明書を 
.B MJ.cer 
という名前のファイルにコピーします。このエントリには「
.BR  mykey
」という別名が使われているとします。 
.LP
.ft 3
.nf
keytool \-export \-alias mykey \-file MJ.cer
.fi
.ft 1
.LP
証明書と署名付き JAR ファイルを入手したクライアントは、
.BR jarsigner (1)
ツールを使って署名を認証できます。 
.LP
.SS "鍵のペアを保持したまま"
.SS "での識別名の変更"
.IX "keytool" "Changing Your Distinguished Name but Keeping your Key Pair" "\fLkeytool\fP \(em key and certificate management tool"
.LP
所属部課の変更や転勤などによって、識別名が変更されたとします。このような
場合は、識別名を更新する一方で、引き続き以前と同じ公開鍵と非公開鍵の
ペアを使用することができます。たとえば、名前が Susan Miller で、以前に
.B sMiller
という別名で鍵エントリを作成していたとします。識別名は、次のように指定して
いました。 
.LP
.ft 3
.nf
"cn=Susan Miller, ou=Finance Department, o=BlueSoft, c=us"
.fi
.ft 1
.LP
ここで、所属部課が Finance Department から Accounting Department に
変更になったとします。この場合、以前に生成した公開鍵と非公開鍵のペアを
使い続けながら識別名を更新するには、次のようにします。 まず、鍵エントリを
コピー (複製) します。 
.LP
.ft 3
.nf
keytool \-keyclone \-alias sMiller \-dest sMillerNew
.fi
.ft 1
.LP
この例では、ストアのパスワードおよび元の非公開鍵のパスワードと複製先の
非公開鍵のパスワードをコマンド行で指定していないので、パスワードの入力を
求められます。鍵エントリをコピーしたあとは、連鎖内の最初の証明書が変更後
の識別名を使うようにするために、コピーした鍵エントリに関連付けられている
証明連鎖を変更する必要があります。まず、適切な名前で自己署名証明書を
生成します。 
.LP
.ft 3
.nf
keytool \-selfcert \-alias sMillerNew
-dname "cn=Susan Miller, ou=Accounting Department, o=BlueSoft, c=us"
.fi
.ft 1
.LP
次に、この新しい証明書の情報に基づいて証明書署名要求を生成します。 
.LP
.ft 3
.nf
keytool \-certreq \-alias sMillerNew
.fi
.ft 1
.LP
CA の証明書応答を入手したら、応答をインポートします。 
.LP
.ft 3
.nf
keytool \-import \-alias sMillerNew \-file VSSMillerNew.cer
.fi
.ft 1
.LP
証明書応答のインポート後は、古い識別名が使われている元の鍵エントリを削除できます。 
.LP
.ft 3
.nf
keytool \-delete \-alias sMiller
.fi
.ft 1
.br
.ne 11
.SH "関連項目"
.BR  jar (1),
.BR  jarsigner (1)
.LP
次については、
.BR java.sun.com
を参照または検索してください。
.TP 10
.B Security in Java 2 Platform @
http://java.sun.com/docs/books/tutorial/security1.2/index.html
